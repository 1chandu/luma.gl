"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Default Shaders

// TODO - adopt glslify
var Shaders = {
  Vertex: {},
  Fragment: {}
};

Shaders.Vertex.Default = "\n#define LIGHT_MAX 4\n\n// object attributes\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 color;\nattribute vec4 pickingColor;\nattribute vec2 texCoord1;\n\n// camera and object matrices\nuniform mat4 viewMatrix;\nuniform mat4 viewInverseMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\n\n// objectMatrix * viewMatrix = worldMatrix\nuniform mat4 worldMatrix;\nuniform mat4 worldInverseMatrix;\nuniform mat4 worldInverseTransposeMatrix;\nuniform mat4 objectMatrix;\nuniform vec3 cameraPosition;\n\n// lighting configuration\nuniform bool enableLights;\nuniform vec3 ambientColor;\nuniform vec3 directionalColor;\nuniform vec3 lightingDirection;\n\n// point lights configuration\nuniform vec3 pointLocation[LIGHT_MAX];\nuniform vec3 pointColor[LIGHT_MAX];\nuniform int numberPoints;\n\n// reflection / refraction configuration\nuniform bool useReflection;\n\n// varyings\nvarying vec3 vReflection;\nvarying vec4 vColor;\nvarying vec4 vPickingColor;\nvarying vec2 vTexCoord;\nvarying vec4 vNormal;\nvarying vec3 lightWeighting;\n\nvoid main(void) {\n  vec4 mvPosition = worldMatrix * vec4(position, 1.0);\n  vec4 transformedNormal = worldInverseTransposeMatrix * vec4(normal, 1.0);\n\n  // lighting code\n  if(!enableLights) {\n    lightWeighting = vec3(1.0, 1.0, 1.0);\n  } else {\n    vec3 plightDirection;\n    vec3 pointWeight = vec3(0.0, 0.0, 0.0);\n    float directionalLightWeighting =\n      max(dot(transformedNormal.xyz, lightingDirection), 0.0);\n    for (int i = 0; i < LIGHT_MAX; i++) {\n      if (i < numberPoints) {\n        plightDirection = normalize(\n          (viewMatrix * vec4(pointLocation[i], 1.0)).xyz - mvPosition.xyz);\n         pointWeight += max(\n          dot(transformedNormal.xyz, plightDirection), 0.0) * pointColor[i];\n       } else {\n         break;\n       }\n     }\n\n    lightWeighting = ambientColor +\n      (directionalColor * directionalLightWeighting) + pointWeight;\n  }\n\n  // refraction / reflection code\n  if (useReflection) {\n    vReflection =\n      (viewInverseMatrix[3] - (worldMatrix * vec4(position, 1.0))).xyz;\n  } else {\n    vReflection = vec3(1.0, 1.0, 1.0);\n  }\n\n  // pass results to varyings\n  vColor = color;\n  vPickingColor = pickingColor;\n  vTexCoord = texCoord1;\n  vNormal = transformedNormal;\n  gl_Position = projectionMatrix * worldMatrix * vec4(position, 1.0);\n}\n";

Shaders.Fragment.Default = "\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// varyings\nvarying vec4 vColor;\nvarying vec4 vPickingColor;\nvarying vec2 vTexCoord;\nvarying vec3 lightWeighting;\nvarying vec3 vReflection;\nvarying vec4 vNormal;\n\n// texture configs\nuniform bool hasTexture1;\nuniform sampler2D sampler1;\nuniform bool hasTextureCube1;\nuniform samplerCube samplerCube1;\n\n// picking configs\nuniform bool enablePicking;\nuniform bool hasPickingColors;\nuniform vec3 pickColor;\n\n// reflection / refraction configs\nuniform float reflection;\nuniform float refraction;\n\n// fog configuration\nuniform bool hasFog;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvoid main(){\n  // set color from texture\n  if (!hasTexture1) {\n    gl_FragColor = vec4(vColor.rgb * lightWeighting, vColor.a);\n  } else {\n    gl_FragColor =\n      vec4(texture2D(sampler1, vec2(vTexCoord.s, vTexCoord.t)).rgb *\n      lightWeighting, 1.0);\n  }\n\n  // has cube texture then apply reflection\n  if (hasTextureCube1) {\n    vec3 nReflection = normalize(vReflection);\n    vec3 reflectionValue;\n    if (refraction > 0.0) {\n     reflectionValue = refract(nReflection, vNormal.xyz, refraction);\n    } else {\n     reflectionValue = -reflect(nReflection, vNormal.xyz);\n    }\n\n    // TODO(nico): check whether this is right.\n    vec4 cubeColor = textureCube(samplerCube1,\n        vec3(-reflectionValue.x, -reflectionValue.y, reflectionValue.z));\n    gl_FragColor = vec4(mix(gl_FragColor.xyz, cubeColor.xyz, reflection), 1.0);\n  }\n\n  // set picking\n  if (enablePicking) {\n    if (hasPickingColors) {\n      gl_FragColor = vPickingColor;\n    } else {\n      gl_FragColor = vec4(pickColor, 1.0);\n    }\n  }\n\n  // handle fog\n  if (hasFog) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep(fogNear, fogFar, depth);\n    gl_FragColor =\n      mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);\n   }\n }\n";

exports.default = Shaders;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zaGFkZXJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBR0EsSUFBTSxVQUFVO0FBQ2QsVUFBUSxFQUFSO0FBQ0EsWUFBVSxFQUFWO0NBRkk7O0FBS04sUUFBUSxNQUFSLENBQWUsT0FBZjs7QUF5RkEsUUFBUSxRQUFSLENBQWlCLE9BQWpCOztrQkFnRmUiLCJmaWxlIjoic2hhZGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIERlZmF1bHQgU2hhZGVyc1xuXG4vLyBUT0RPIC0gYWRvcHQgZ2xzbGlmeVxuY29uc3QgU2hhZGVycyA9IHtcbiAgVmVydGV4OiB7fSxcbiAgRnJhZ21lbnQ6IHt9XG59O1xuXG5TaGFkZXJzLlZlcnRleC5EZWZhdWx0ID0gYFxuI2RlZmluZSBMSUdIVF9NQVggNFxuXG4vLyBvYmplY3QgYXR0cmlidXRlc1xuYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XG5hdHRyaWJ1dGUgdmVjNCBjb2xvcjtcbmF0dHJpYnV0ZSB2ZWM0IHBpY2tpbmdDb2xvcjtcbmF0dHJpYnV0ZSB2ZWMyIHRleENvb3JkMTtcblxuLy8gY2FtZXJhIGFuZCBvYmplY3QgbWF0cmljZXNcbnVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHZpZXdJbnZlcnNlTWF0cml4O1xudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XG51bmlmb3JtIG1hdDQgdmlld1Byb2plY3Rpb25NYXRyaXg7XG5cbi8vIG9iamVjdE1hdHJpeCAqIHZpZXdNYXRyaXggPSB3b3JsZE1hdHJpeFxudW5pZm9ybSBtYXQ0IHdvcmxkTWF0cml4O1xudW5pZm9ybSBtYXQ0IHdvcmxkSW52ZXJzZU1hdHJpeDtcbnVuaWZvcm0gbWF0NCB3b3JsZEludmVyc2VUcmFuc3Bvc2VNYXRyaXg7XG51bmlmb3JtIG1hdDQgb2JqZWN0TWF0cml4O1xudW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1xuXG4vLyBsaWdodGluZyBjb25maWd1cmF0aW9uXG51bmlmb3JtIGJvb2wgZW5hYmxlTGlnaHRzO1xudW5pZm9ybSB2ZWMzIGFtYmllbnRDb2xvcjtcbnVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbENvbG9yO1xudW5pZm9ybSB2ZWMzIGxpZ2h0aW5nRGlyZWN0aW9uO1xuXG4vLyBwb2ludCBsaWdodHMgY29uZmlndXJhdGlvblxudW5pZm9ybSB2ZWMzIHBvaW50TG9jYXRpb25bTElHSFRfTUFYXTtcbnVuaWZvcm0gdmVjMyBwb2ludENvbG9yW0xJR0hUX01BWF07XG51bmlmb3JtIGludCBudW1iZXJQb2ludHM7XG5cbi8vIHJlZmxlY3Rpb24gLyByZWZyYWN0aW9uIGNvbmZpZ3VyYXRpb25cbnVuaWZvcm0gYm9vbCB1c2VSZWZsZWN0aW9uO1xuXG4vLyB2YXJ5aW5nc1xudmFyeWluZyB2ZWMzIHZSZWZsZWN0aW9uO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbnZhcnlpbmcgdmVjNCB2Tm9ybWFsO1xudmFyeWluZyB2ZWMzIGxpZ2h0V2VpZ2h0aW5nO1xuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWM0IG12UG9zaXRpb24gPSB3b3JsZE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gIHZlYzQgdHJhbnNmb3JtZWROb3JtYWwgPSB3b3JsZEludmVyc2VUcmFuc3Bvc2VNYXRyaXggKiB2ZWM0KG5vcm1hbCwgMS4wKTtcblxuICAvLyBsaWdodGluZyBjb2RlXG4gIGlmKCFlbmFibGVMaWdodHMpIHtcbiAgICBsaWdodFdlaWdodGluZyA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XG4gIH0gZWxzZSB7XG4gICAgdmVjMyBwbGlnaHREaXJlY3Rpb247XG4gICAgdmVjMyBwb2ludFdlaWdodCA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XG4gICAgZmxvYXQgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZyA9XG4gICAgICBtYXgoZG90KHRyYW5zZm9ybWVkTm9ybWFsLnh5eiwgbGlnaHRpbmdEaXJlY3Rpb24pLCAwLjApO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTElHSFRfTUFYOyBpKyspIHtcbiAgICAgIGlmIChpIDwgbnVtYmVyUG9pbnRzKSB7XG4gICAgICAgIHBsaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZShcbiAgICAgICAgICAodmlld01hdHJpeCAqIHZlYzQocG9pbnRMb2NhdGlvbltpXSwgMS4wKSkueHl6IC0gbXZQb3NpdGlvbi54eXopO1xuICAgICAgICAgcG9pbnRXZWlnaHQgKz0gbWF4KFxuICAgICAgICAgIGRvdCh0cmFuc2Zvcm1lZE5vcm1hbC54eXosIHBsaWdodERpcmVjdGlvbiksIDAuMCkgKiBwb2ludENvbG9yW2ldO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBicmVhaztcbiAgICAgICB9XG4gICAgIH1cblxuICAgIGxpZ2h0V2VpZ2h0aW5nID0gYW1iaWVudENvbG9yICtcbiAgICAgIChkaXJlY3Rpb25hbENvbG9yICogZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZykgKyBwb2ludFdlaWdodDtcbiAgfVxuXG4gIC8vIHJlZnJhY3Rpb24gLyByZWZsZWN0aW9uIGNvZGVcbiAgaWYgKHVzZVJlZmxlY3Rpb24pIHtcbiAgICB2UmVmbGVjdGlvbiA9XG4gICAgICAodmlld0ludmVyc2VNYXRyaXhbM10gLSAod29ybGRNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKSkueHl6O1xuICB9IGVsc2Uge1xuICAgIHZSZWZsZWN0aW9uID0gdmVjMygxLjAsIDEuMCwgMS4wKTtcbiAgfVxuXG4gIC8vIHBhc3MgcmVzdWx0cyB0byB2YXJ5aW5nc1xuICB2Q29sb3IgPSBjb2xvcjtcbiAgdlBpY2tpbmdDb2xvciA9IHBpY2tpbmdDb2xvcjtcbiAgdlRleENvb3JkID0gdGV4Q29vcmQxO1xuICB2Tm9ybWFsID0gdHJhbnNmb3JtZWROb3JtYWw7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHdvcmxkTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbn1cbmA7XG5cblNoYWRlcnMuRnJhZ21lbnQuRGVmYXVsdCA9IGBcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxuLy8gdmFyeWluZ3NcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzQgdlBpY2tpbmdDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG52YXJ5aW5nIHZlYzMgbGlnaHRXZWlnaHRpbmc7XG52YXJ5aW5nIHZlYzMgdlJlZmxlY3Rpb247XG52YXJ5aW5nIHZlYzQgdk5vcm1hbDtcblxuLy8gdGV4dHVyZSBjb25maWdzXG51bmlmb3JtIGJvb2wgaGFzVGV4dHVyZTE7XG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyMTtcbnVuaWZvcm0gYm9vbCBoYXNUZXh0dXJlQ3ViZTE7XG51bmlmb3JtIHNhbXBsZXJDdWJlIHNhbXBsZXJDdWJlMTtcblxuLy8gcGlja2luZyBjb25maWdzXG51bmlmb3JtIGJvb2wgZW5hYmxlUGlja2luZztcbnVuaWZvcm0gYm9vbCBoYXNQaWNraW5nQ29sb3JzO1xudW5pZm9ybSB2ZWMzIHBpY2tDb2xvcjtcblxuLy8gcmVmbGVjdGlvbiAvIHJlZnJhY3Rpb24gY29uZmlnc1xudW5pZm9ybSBmbG9hdCByZWZsZWN0aW9uO1xudW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uO1xuXG4vLyBmb2cgY29uZmlndXJhdGlvblxudW5pZm9ybSBib29sIGhhc0ZvZztcbnVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcbnVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcbnVuaWZvcm0gZmxvYXQgZm9nRmFyO1xuXG52b2lkIG1haW4oKXtcbiAgLy8gc2V0IGNvbG9yIGZyb20gdGV4dHVyZVxuICBpZiAoIWhhc1RleHR1cmUxKSB7XG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IucmdiICogbGlnaHRXZWlnaHRpbmcsIHZDb2xvci5hKTtcbiAgfSBlbHNlIHtcbiAgICBnbF9GcmFnQ29sb3IgPVxuICAgICAgdmVjNCh0ZXh0dXJlMkQoc2FtcGxlcjEsIHZlYzIodlRleENvb3JkLnMsIHZUZXhDb29yZC50KSkucmdiICpcbiAgICAgIGxpZ2h0V2VpZ2h0aW5nLCAxLjApO1xuICB9XG5cbiAgLy8gaGFzIGN1YmUgdGV4dHVyZSB0aGVuIGFwcGx5IHJlZmxlY3Rpb25cbiAgaWYgKGhhc1RleHR1cmVDdWJlMSkge1xuICAgIHZlYzMgblJlZmxlY3Rpb24gPSBub3JtYWxpemUodlJlZmxlY3Rpb24pO1xuICAgIHZlYzMgcmVmbGVjdGlvblZhbHVlO1xuICAgIGlmIChyZWZyYWN0aW9uID4gMC4wKSB7XG4gICAgIHJlZmxlY3Rpb25WYWx1ZSA9IHJlZnJhY3QoblJlZmxlY3Rpb24sIHZOb3JtYWwueHl6LCByZWZyYWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICByZWZsZWN0aW9uVmFsdWUgPSAtcmVmbGVjdChuUmVmbGVjdGlvbiwgdk5vcm1hbC54eXopO1xuICAgIH1cblxuICAgIC8vIFRPRE8obmljbyk6IGNoZWNrIHdoZXRoZXIgdGhpcyBpcyByaWdodC5cbiAgICB2ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKHNhbXBsZXJDdWJlMSxcbiAgICAgICAgdmVjMygtcmVmbGVjdGlvblZhbHVlLngsIC1yZWZsZWN0aW9uVmFsdWUueSwgcmVmbGVjdGlvblZhbHVlLnopKTtcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChnbF9GcmFnQ29sb3IueHl6LCBjdWJlQ29sb3IueHl6LCByZWZsZWN0aW9uKSwgMS4wKTtcbiAgfVxuXG4gIC8vIHNldCBwaWNraW5nXG4gIGlmIChlbmFibGVQaWNraW5nKSB7XG4gICAgaWYgKGhhc1BpY2tpbmdDb2xvcnMpIHtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZQaWNraW5nQ29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocGlja0NvbG9yLCAxLjApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBmb2dcbiAgaWYgKGhhc0ZvZykge1xuICAgIGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcbiAgICBmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGgpO1xuICAgIGdsX0ZyYWdDb2xvciA9XG4gICAgICBtaXgoZ2xfRnJhZ0NvbG9yLCB2ZWM0KGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyksIGZvZ0ZhY3Rvcik7XG4gICB9XG4gfVxuYDtcblxuZXhwb3J0IGRlZmF1bHQgU2hhZGVycztcbiJdfQ==