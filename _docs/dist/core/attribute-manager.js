'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable guard-for-in */


var _utils = require('../utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function noop() {}

var AttributeManager = function () {
  /**
   * @classdesc
   * Automated attribute generation and management. Suitable when a set of
   * vertex shader attributes are generated by iteration over a data array,
   * and updates to these attributes are needed either when the data itself
   * changes, or when other data relevant to the calculations change.
   *
   * - First the application registers descriptions of its dynamic vertex
   *   attributes using AttributeManager.add().
   * - Then, when any change that affects attributes is detected by the
   *   application, the app will call AttributeManager.invalidate().
   * - Finally before it renders, it calls AttributeManager.update() to
   *   ensure that attributes are automatically rebuilt if anything has been
   *   invalidated.
   *
   * The application provided update functions describe how attributes
   * should be updated from a data array and are expected to traverse
   * that data array (or iterable) and fill in the attribute's typed array.
   *
   * Note that the attribute manager intentionally does not do advanced
   * change detection, but instead makes it easy to build such detection
   * by offering the ability to "invalidate" each attribute separately.
   *
   * Summary:
   * - keeps track of valid state for each attribute
   * - auto reallocates attributes when needed
   * - auto updates attributes with registered updater functions
   * - allows overriding with application supplied buffers
   *
   * Limitations:
   * - There are currently no provisions for only invalidating a range of
   *   indices in an attribute.
   *
   * @class
   * @param {Object} [props]
   * @param {String} [props.id] - identifier (for debugging)
   */
  function AttributeManager() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$id = _ref.id;
    var id = _ref$id === undefined ? 'attribute-manager' : _ref$id;

    var otherProps = _objectWithoutProperties(_ref, ['id']);

    _classCallCheck(this, AttributeManager);

    this.id = id;
    this.attributes = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;
    this.userData = {};

    this.onUpdateStart = noop;
    this.onUpdateEnd = noop;
    this.onLog = this._defaultLog;

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    // Marks an attribute for update

  }, {
    key: 'invalidate',
    value: function invalidate(attributeName) {
      var attributes = this.attributes;

      var attribute = attributes[attributeName];
      (0, _assert2.default)(attribute);
      attribute.needsUpdate = true;
      // For performance tuning
      this.onLog(1, 'invalidated attribute ' + attributeName + ' for ' + this.id);
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        this.invalidate(attributeName);
      }
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var data = _ref2.data;
      var numInstances = _ref2.numInstances;
      var _ref2$buffers = _ref2.buffers;
      var buffers = _ref2$buffers === undefined ? {} : _ref2$buffers;
      var _ref2$props = _ref2.props;
      var props = _ref2$props === undefined ? {} : _ref2$props;
      var _ref2$context = _ref2.context;
      var context = _ref2$context === undefined ? {} : _ref2$context;

      var opts = _objectWithoutProperties(_ref2, ['data', 'numInstances', 'buffers', 'props', 'context']);

      // First apply any application provided buffers
      this._checkExternalBuffers(buffers, opts);
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        this.onUpdateStart(this.id);
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        this.onUpdateEnd(this.id);
      }
    }

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses luma logger.
     *
     * Note that the app may not be in control of when update is called,
     * so hooks are provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */

  }, {
    key: 'setLogFunctions',
    value: function setLogFunctions() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var onLog = _ref3.onLog;
      var onUpdateStart = _ref3.onUpdateStart;
      var onUpdateEnd = _ref3.onUpdateEnd;

      this.onLog = onLog !== undefined ? onLog : this.onLog;
      this.onUpdateStart = onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;
      this.onUpdateEnd = onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref4) {
      var _ref4$clearChangedFla = _ref4.clearChangedFlags;
      var clearChangedFlags = _ref4$clearChangedFla === undefined ? false : _ref4$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {Boolean} - whether a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref5$clearRedrawFlag = _ref5.clearRedrawFlags;
      var clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;

      var redraw = this.needsRedraw;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addDynamic',
    value: function addDynamic(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PRIVATE METHODS

    // Default logger

  }, {
    key: '_defaultLog',
    value: function _defaultLog(level, message) {
      _utils.log.log(level, message);
    }

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = _extends({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        // Check all fields and generate helpful error messages
        this._validate(attributeName, attribute);

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = _extends({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          isIndexed: false,

          // Reserved for application
          userData: {}

        }, attribute, {

          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          size: attribute.size,
          value: attribute.value || null

        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Add to both attributes list (for registration with model)
        this.attributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);
    }
  }, {
    key: '_validate',
    value: function _validate(attributeName, attribute) {
      (0, _assert2.default)(typeof attribute.size === 'number', 'Attribute definition for ' + attributeName + ' missing size');

      // Check the updater
      (0, _assert2.default)(typeof attribute.update === 'function' || attribute.noAlloc, 'Attribute updater for ' + attributeName + ' missing update method');
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var bufferMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var attributes = this.attributes;

      for (var attributeName in bufferMap) {
        var attribute = attributes[attributeName];
        if (!attribute && !opts.ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = bufferMap[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes;
      var numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          if (!(buffer instanceof Float32Array)) {
            throw new Error('Attribute properties must be of type Float32Array');
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref6) {
      var numInstances = _ref6.numInstances;
      var attributes = this.attributes;

      (0, _assert2.default)(numInstances !== undefined);

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && attribute.update) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref7) {
      var numInstances = _ref7.numInstances;
      var data = _ref7.data;
      var props = _ref7.props;
      var context = _ref7.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = attribute.type || Float32Array;
          attribute.value = new ArrayType(attribute.size * allocCount);
          this.onLog(2, this.id + ':' + attributeName + ' allocated ' + allocCount);
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }

        // Call updater function if needed
        if (attribute.needsUpdate) {
          var update = attribute.update;

          if (update) {
            this.onLog(2, this.id + ':' + attributeName + ' updating ' + numInstances);
            update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
          } else {
            this.onLog(2, this.id + ':' + attributeName + ' missing update function');
          }
          attribute.needsUpdate = false;
          attribute.changed = true;
          this.needsRedraw = true;
        }
      }

      this.allocedInstances = allocCount;
    }
    /* eslint-enable max-statements */

  }]);

  return AttributeManager;
}();

exports.default = AttributeManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2F0dHJpYnV0ZS1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIm5vb3AiLCJBdHRyaWJ1dGVNYW5hZ2VyIiwiaWQiLCJvdGhlclByb3BzIiwiYXR0cmlidXRlcyIsImFsbG9jZWRJbnN0YW5jZXMiLCJuZWVkc1JlZHJhdyIsInVzZXJEYXRhIiwib25VcGRhdGVTdGFydCIsIm9uVXBkYXRlRW5kIiwib25Mb2ciLCJfZGVmYXVsdExvZyIsIk9iamVjdCIsInNlYWwiLCJ1cGRhdGVycyIsIl9hZGQiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlIiwibmVlZHNVcGRhdGUiLCJpbnZhbGlkYXRlIiwiZGF0YSIsIm51bUluc3RhbmNlcyIsImJ1ZmZlcnMiLCJwcm9wcyIsImNvbnRleHQiLCJvcHRzIiwiX2NoZWNrRXh0ZXJuYWxCdWZmZXJzIiwiX3NldEV4dGVybmFsQnVmZmVycyIsIl9hbmFseXplQnVmZmVycyIsIl91cGRhdGVCdWZmZXJzIiwidW5kZWZpbmVkIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImNoYW5nZWQiLCJjbGVhclJlZHJhd0ZsYWdzIiwicmVkcmF3IiwiaW5zdGFuY2VkIiwibGV2ZWwiLCJtZXNzYWdlIiwibG9nIiwiX2V4dHJhUHJvcHMiLCJuZXdBdHRyaWJ1dGVzIiwiX3ZhbGlkYXRlIiwiYXR0cmlidXRlRGF0YSIsInRhcmdldCIsImlzSW5kZXhlZCIsImlzRXh0ZXJuYWxCdWZmZXIiLCJuZWVkc0FsbG9jIiwic2l6ZSIsInZhbHVlIiwiYXNzaWduIiwidXBkYXRlIiwibm9BbGxvYyIsImJ1ZmZlck1hcCIsImlnbm9yZVVua25vd25BdHRyaWJ1dGVzIiwiRXJyb3IiLCJidWZmZXIiLCJGbG9hdDMyQXJyYXkiLCJhdXRvIiwibGVuZ3RoIiwiYWxsb2NDb3VudCIsIk1hdGgiLCJtYXgiLCJBcnJheVR5cGUiLCJ0eXBlIiwiY2FsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FqQkFBQTs7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LEVBQWNGLDBCQUFkLEVBQWhDO0FBQ0QsV0FIRCxNQUdPO0FBQ0wsaUJBQUtYLEtBQUwsQ0FBVyxDQUFYLEVBQWlCLEtBQUtSLEVBQXRCLFNBQTRCYyxhQUE1QjtBQUNEO0FBQ0RDLG9CQUFVQyxXQUFWLEdBQXdCLEtBQXhCO0FBQ0FELG9CQUFVZ0IsT0FBVixHQUFvQixJQUFwQjtBQUNBLGVBQUszQixXQUFMLEdBQW1CLElBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxXQUFLRCxnQkFBTCxHQUF3QnVELFVBQXhCO0FBQ0Q7QUFDRDs7Ozs7OztrQkEzYW1CM0QsZ0IiLCJmaWxlIjoiYXR0cmlidXRlLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbmltcG9ydCB7bG9nfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlTWFuYWdlciB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEF1dG9tYXRlZCBhdHRyaWJ1dGUgZ2VuZXJhdGlvbiBhbmQgbWFuYWdlbWVudC4gU3VpdGFibGUgd2hlbiBhIHNldCBvZlxuICAgKiB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZXMgYXJlIGdlbmVyYXRlZCBieSBpdGVyYXRpb24gb3ZlciBhIGRhdGEgYXJyYXksXG4gICAqIGFuZCB1cGRhdGVzIHRvIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIG5lZWRlZCBlaXRoZXIgd2hlbiB0aGUgZGF0YSBpdHNlbGZcbiAgICogY2hhbmdlcywgb3Igd2hlbiBvdGhlciBkYXRhIHJlbGV2YW50IHRvIHRoZSBjYWxjdWxhdGlvbnMgY2hhbmdlLlxuICAgKlxuICAgKiAtIEZpcnN0IHRoZSBhcHBsaWNhdGlvbiByZWdpc3RlcnMgZGVzY3JpcHRpb25zIG9mIGl0cyBkeW5hbWljIHZlcnRleFxuICAgKiAgIGF0dHJpYnV0ZXMgdXNpbmcgQXR0cmlidXRlTWFuYWdlci5hZGQoKS5cbiAgICogLSBUaGVuLCB3aGVuIGFueSBjaGFuZ2UgdGhhdCBhZmZlY3RzIGF0dHJpYnV0ZXMgaXMgZGV0ZWN0ZWQgYnkgdGhlXG4gICAqICAgYXBwbGljYXRpb24sIHRoZSBhcHAgd2lsbCBjYWxsIEF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgpLlxuICAgKiAtIEZpbmFsbHkgYmVmb3JlIGl0IHJlbmRlcnMsIGl0IGNhbGxzIEF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKCkgdG9cbiAgICogICBlbnN1cmUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgaWYgYW55dGhpbmcgaGFzIGJlZW5cbiAgICogICBpbnZhbGlkYXRlZC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3ZpZGVkIHVwZGF0ZSBmdW5jdGlvbnMgZGVzY3JpYmUgaG93IGF0dHJpYnV0ZXNcbiAgICogc2hvdWxkIGJlIHVwZGF0ZWQgZnJvbSBhIGRhdGEgYXJyYXkgYW5kIGFyZSBleHBlY3RlZCB0byB0cmF2ZXJzZVxuICAgKiB0aGF0IGRhdGEgYXJyYXkgKG9yIGl0ZXJhYmxlKSBhbmQgZmlsbCBpbiB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIG1hbmFnZXIgaW50ZW50aW9uYWxseSBkb2VzIG5vdCBkbyBhZHZhbmNlZFxuICAgKiBjaGFuZ2UgZGV0ZWN0aW9uLCBidXQgaW5zdGVhZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHN1Y2ggZGV0ZWN0aW9uXG4gICAqIGJ5IG9mZmVyaW5nIHRoZSBhYmlsaXR5IHRvIFwiaW52YWxpZGF0ZVwiIGVhY2ggYXR0cmlidXRlIHNlcGFyYXRlbHkuXG4gICAqXG4gICAqIFN1bW1hcnk6XG4gICAqIC0ga2VlcHMgdHJhY2sgb2YgdmFsaWQgc3RhdGUgZm9yIGVhY2ggYXR0cmlidXRlXG4gICAqIC0gYXV0byByZWFsbG9jYXRlcyBhdHRyaWJ1dGVzIHdoZW4gbmVlZGVkXG4gICAqIC0gYXV0byB1cGRhdGVzIGF0dHJpYnV0ZXMgd2l0aCByZWdpc3RlcmVkIHVwZGF0ZXIgZnVuY3Rpb25zXG4gICAqIC0gYWxsb3dzIG92ZXJyaWRpbmcgd2l0aCBhcHBsaWNhdGlvbiBzdXBwbGllZCBidWZmZXJzXG4gICAqXG4gICAqIExpbWl0YXRpb25zOlxuICAgKiAtIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gcHJvdmlzaW9ucyBmb3Igb25seSBpbnZhbGlkYXRpbmcgYSByYW5nZSBvZlxuICAgKiAgIGluZGljZXMgaW4gYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wcy5pZF0gLSBpZGVudGlmaWVyIChmb3IgZGVidWdnaW5nKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGlkID0gJ2F0dHJpYnV0ZS1tYW5hZ2VyJyxcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSAtMTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLnVzZXJEYXRhID0ge307XG5cbiAgICB0aGlzLm9uVXBkYXRlU3RhcnQgPSBub29wO1xuICAgIHRoaXMub25VcGRhdGVFbmQgPSBub29wO1xuICAgIHRoaXMub25Mb2cgPSB0aGlzLl9kZWZhdWx0TG9nO1xuXG4gICAgLy8gRm9yIGRlYnVnZ2luZyBzYW5pdHksIHByZXZlbnQgdW5pbml0aWFsaXplZCBtZW1iZXJzXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAqIFRha2VzIGEgbWFwIG9mIGF0dHJpYnV0ZSBkZXNjcmlwdG9yIG9iamVjdHNcbiAgICogLSBrZXlzIGFyZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICogLSB2YWx1ZXMgYXJlIG9iamVjdHMgd2l0aCBhdHRyaWJ1dGUgZmllbGRzXG4gICAqXG4gICAqIGF0dHJpYnV0ZS5zaXplIC0gbnVtYmVyIG9mIGVsZW1lbnRzIHBlciBvYmplY3RcbiAgICogYXR0cmlidXRlLnVwZGF0ZXIgLSBudW1iZXIgb2YgZWxlbWVudHNcbiAgICogYXR0cmlidXRlLmluc3RhbmNlZD0wIC0gaXMgdGhpcyBpcyBhbiBpbnN0YW5jZWQgYXR0cmlidXRlIChhLmsuYS4gZGl2aXNvcilcbiAgICogYXR0cmlidXRlLm5vQWxsb2M9ZmFsc2UgLSBpZiB0aGlzIGF0dHJpYnV0ZSBzaG91bGQgbm90IGJlIGFsbG9jYXRlZFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAqICAgcG9zaXRpb25zOiB7c2l6ZTogMiwgdXBkYXRlOiBjYWxjdWxhdGVQb3NpdGlvbnN9XG4gICAqICAgY29sb3JzOiB7c2l6ZTogMywgdXBkYXRlOiBjYWxjdWxhdGVDb2xvcnN9XG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBtYXAgKHNlZSBhYm92ZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAqL1xuICBhZGQoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSkge1xuICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyk7XG4gIH1cblxuICAvLyBNYXJrcyBhbiBhdHRyaWJ1dGUgZm9yIHVwZGF0ZVxuICBpbnZhbGlkYXRlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgYXNzZXJ0KGF0dHJpYnV0ZSk7XG4gICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgdHVuaW5nXG4gICAgdGhpcy5vbkxvZygxLCBgaW52YWxpZGF0ZWQgYXR0cmlidXRlICR7YXR0cmlidXRlTmFtZX0gZm9yICR7dGhpcy5pZH1gKTtcbiAgfVxuXG4gIGludmFsaWRhdGVBbGwoKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYWxsIGF0dHJpYnV0ZSBidWZmZXJzIGFyZSB1cGRhdGVkIGZyb20gcHJvcHMgb3IgZGF0YS5cbiAgICpcbiAgICogTm90ZTogQW55IHByZWFsbG9jYXRlZCBidWZmZXJzIGluIFwiYnVmZmVyc1wiIG1hdGNoaW5nIHJlZ2lzdGVyZWQgYXR0cmlidXRlXG4gICAqIG5hbWVzIHdpbGwgYmUgdXNlZC4gTm8gdXBkYXRlIHdpbGwgaGFwcGVuIGluIHRoaXMgY2FzZS5cbiAgICogTm90ZTogQ2FsbHMgb25VcGRhdGVTdGFydCBhbmQgb25VcGRhdGVFbmQgbG9nIGNhbGxiYWNrcyBiZWZvcmUgYW5kIGFmdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSAtIGRhdGEgKGl0ZXJhYmxlIG9iamVjdClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMubnVtSW5zdGFuY2VzIC0gY291bnQgb2YgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5idWZmZXJzID0ge30gLSBwcmUtYWxsb2NhdGVkIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcHMgLSBwYXNzZWQgdG8gdXBkYXRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udGV4dCAtIFVzZWQgYXMgXCJ0aGlzXCIgY29udGV4dCBmb3IgdXBkYXRlcnNcbiAgICovXG4gIHVwZGF0ZSh7XG4gICAgZGF0YSxcbiAgICBudW1JbnN0YW5jZXMsXG4gICAgYnVmZmVycyA9IHt9LFxuICAgIHByb3BzID0ge30sXG4gICAgY29udGV4dCA9IHt9LFxuICAgIC4uLm9wdHNcbiAgfSA9IHt9KSB7XG4gICAgLy8gRmlyc3QgYXBwbHkgYW55IGFwcGxpY2F0aW9uIHByb3ZpZGVkIGJ1ZmZlcnNcbiAgICB0aGlzLl9jaGVja0V4dGVybmFsQnVmZmVycyhidWZmZXJzLCBvcHRzKTtcbiAgICB0aGlzLl9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVycyk7XG5cbiAgICAvLyBPbmx5IGluaXRpYXRlIGFsbG9jL3VwZGF0ZSAoYW5kIGxvZ2dpbmcpIGlmIGFjdHVhbGx5IG5lZWRlZFxuICAgIGlmICh0aGlzLl9hbmFseXplQnVmZmVycyh7bnVtSW5zdGFuY2VzfSkpIHtcbiAgICAgIHRoaXMub25VcGRhdGVTdGFydCh0aGlzLmlkKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlcnMoe251bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KTtcbiAgICAgIHRoaXMub25VcGRhdGVFbmQodGhpcy5pZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbG9nIGZ1bmN0aW9ucyB0byBoZWxwIHRyYWNlIG9yIHRpbWUgYXR0cmlidXRlIHVwZGF0ZXMuXG4gICAqIERlZmF1bHQgbG9nZ2luZyB1c2VzIGx1bWEgbG9nZ2VyLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGFwcCBtYXkgbm90IGJlIGluIGNvbnRyb2wgb2Ygd2hlbiB1cGRhdGUgaXMgY2FsbGVkLFxuICAgKiBzbyBob29rcyBhcmUgcHJvdmlkZWQgZm9yIHVwZGF0ZSBzdGFydCBhbmQgZW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vbkxvZz1dIC0gY2FsbGVkIHRvIHByaW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vblVwZGF0ZVN0YXJ0PV0gLSBjYWxsZWQgYmVmb3JlIHVwZGF0ZSgpIHN0YXJ0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVFbmQ9XSAtIGNhbGxlZCBhZnRlciB1cGRhdGUoKSBlbmRzXG4gICAqL1xuICBzZXRMb2dGdW5jdGlvbnMoe1xuICAgIG9uTG9nLFxuICAgIG9uVXBkYXRlU3RhcnQsXG4gICAgb25VcGRhdGVFbmRcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5vbkxvZyA9IG9uTG9nICE9PSB1bmRlZmluZWQgPyBvbkxvZyA6IHRoaXMub25Mb2c7XG4gICAgdGhpcy5vblVwZGF0ZVN0YXJ0ID1cbiAgICAgIG9uVXBkYXRlU3RhcnQgIT09IHVuZGVmaW5lZCA/IG9uVXBkYXRlU3RhcnQgOiB0aGlzLm9uVXBkYXRlU3RhcnQ7XG4gICAgdGhpcy5vblVwZGF0ZUVuZCA9XG4gICAgICBvblVwZGF0ZUVuZCAhPT0gdW5kZWZpbmVkID8gb25VcGRhdGVFbmQgOiB0aGlzLm9uVXBkYXRlRW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuICAgKiBOb3RlOiBGb3JtYXQgbWF0Y2hlcyBsdW1hLmdsIE1vZGVsL1Byb2dyYW0uc2V0QXR0cmlidXRlcygpXG4gICAqIEByZXR1cm4ge09iamVjdH0gYXR0cmlidXRlcyAtIGRlc2NyaXB0b3JzXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjaGFuZ2VkIGF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuICAgKiBUaGlzIGluZGljYXRlcyB3aGljaCBXZWJHTEJ1Z2dlcnMgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0gYXR0cmlidXRlcyAtIGRlc2NyaXB0b3JzXG4gICAqL1xuICBnZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3MgPSBmYWxzZX0pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoYXR0cmlidXRlLmNoYW5nZWQpIHtcbiAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSBhdHRyaWJ1dGUuY2hhbmdlZCAmJiAhY2xlYXJDaGFuZ2VkRmxhZ3M7XG4gICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZEF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVkcmF3IGZsYWcsIG9wdGlvbmFsbHkgY2xlYXJpbmcgaXQuXG4gICAqIFJlZHJhdyBmbGFnIHdpbGwgYmUgc2V0IGlmIGFueSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgY2hhbmdlZCBzaW5jZVxuICAgKiBmbGFnIHdhcyBsYXN0IGNsZWFyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmNsZWFyUmVkcmF3RmxhZ3M9ZmFsc2VdIC0gd2hldGhlciB0byBjbGVhciB0aGUgZmxhZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIHdoZXRoZXIgYSByZWRyYXcgaXMgbmVlZGVkLlxuICAgKi9cbiAgZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGxldCByZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVkcmF3IGZsYWcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3PXRydWVcbiAgICogQHJldHVybiB7QXR0cmlidXRlTWFuYWdlcn0gLSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNSwgdXNlIGFkZCgpIGluc3RlYWRcbiAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZER5bmFtaWMoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSkge1xuICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUsIHVzZSBhZGQoKSBpbnN0ZWFkXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBtYXAgKHNlZSBhYm92ZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAqL1xuICBhZGRJbnN0YW5jZWQoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSkge1xuICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycywge2luc3RhbmNlZDogMX0pO1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gRGVmYXVsdCBsb2dnZXJcbiAgX2RlZmF1bHRMb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICBsb2cubG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIC8vIFVzZWQgdG8gcmVnaXN0ZXIgYW4gYXR0cmlidXRlXG4gIF9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSwgX2V4dHJhUHJvcHMgPSB7fSkge1xuXG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIHN1cHBvcnQgZm9yIHNlcGFyYXRlIHVwZGF0ZSBmdW5jdGlvbiBtYXBcbiAgICAgIC8vIEZvciBub3csIGp1c3QgY29weSBhbnkgYXR0cmlidXRlcyBmcm9tIHRoYXQgbWFwIGludG8gdGhlIG1haW4gbWFwXG4gICAgICAvLyBUT0RPIC0gQXR0cmlidXRlIG1hcHMgYXJlIGEgZGVwcmVjYXRlZCBmZWF0dXJlLCByZW1vdmVcbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lIGluIHVwZGF0ZXJzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB7XG4gICAgICAgICAgLi4uYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSxcbiAgICAgICAgICAuLi51cGRhdGVyc1thdHRyaWJ1dGVOYW1lXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAvLyBDaGVjayBhbGwgZmllbGRzIGFuZCBnZW5lcmF0ZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VzXG4gICAgICB0aGlzLl92YWxpZGF0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUpO1xuXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBhdHRyaWJ1dGUgZGVzY3JpcHRvciwgd2l0aCBXZWJHTCBhbmQgbWV0YWRhdGEgZmllbGRzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVEYXRhID0ge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCBmaWVsZHMgYXJlIHByZXNlbnQgYmVmb3JlIE9iamVjdC5zZWFsKClcbiAgICAgICAgdGFyZ2V0OiB1bmRlZmluZWQsXG4gICAgICAgIGlzSW5kZXhlZDogZmFsc2UsXG5cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIGFwcGxpY2F0aW9uXG4gICAgICAgIHVzZXJEYXRhOiB7fSxcblxuICAgICAgICAvLyBNZXRhZGF0YVxuICAgICAgICAuLi5hdHRyaWJ1dGUsXG5cbiAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgaXNFeHRlcm5hbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgIG5lZWRzQWxsb2M6IGZhbHNlLFxuICAgICAgICBuZWVkc1VwZGF0ZTogZmFsc2UsXG4gICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuXG4gICAgICAgIC8vIEx1bWEgZmllbGRzXG4gICAgICAgIHNpemU6IGF0dHJpYnV0ZS5zaXplLFxuICAgICAgICB2YWx1ZTogYXR0cmlidXRlLnZhbHVlIHx8IG51bGwsXG5cbiAgICAgICAgLi4uX2V4dHJhUHJvcHNcbiAgICAgIH07XG4gICAgICAvLyBTYW5pdHkgLSBubyBhcHAgZmllbGRzIG9uIG91ciBhdHRyaWJ1dGVzLiBVc2UgdXNlckRhdGEgaW5zdGVhZC5cbiAgICAgIE9iamVjdC5zZWFsKGF0dHJpYnV0ZURhdGEpO1xuXG4gICAgICAvLyBBZGQgdG8gYm90aCBhdHRyaWJ1dGVzIGxpc3QgKGZvciByZWdpc3RyYXRpb24gd2l0aCBtb2RlbClcbiAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZURhdGE7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuICB9XG5cbiAgX3ZhbGlkYXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIGFzc2VydCh0eXBlb2YgYXR0cmlidXRlLnNpemUgPT09ICdudW1iZXInLFxuICAgICAgYEF0dHJpYnV0ZSBkZWZpbml0aW9uIGZvciAke2F0dHJpYnV0ZU5hbWV9IG1pc3Npbmcgc2l6ZWApO1xuXG4gICAgLy8gQ2hlY2sgdGhlIHVwZGF0ZXJcbiAgICBhc3NlcnQodHlwZW9mIGF0dHJpYnV0ZS51cGRhdGUgPT09ICdmdW5jdGlvbicgfHwgYXR0cmlidXRlLm5vQWxsb2MsXG4gICAgICBgQXR0cmlidXRlIHVwZGF0ZXIgZm9yICR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgbWV0aG9kYCk7XG4gIH1cblxuICAvLyBDaGVja3MgdGhhdCBhbnkgYXR0cmlidXRlIGJ1ZmZlcnMgaW4gcHJvcHMgYXJlIHZhbGlkXG4gIC8vIE5vdGU6IFRoaXMgaXMganVzdCB0byBoZWxwIGFwcCBjYXRjaCBtaXN0YWtlc1xuICBfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVyTWFwID0ge30sIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGJ1ZmZlck1hcCkge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlICYmICFvcHRzLmlnbm9yZVVua25vd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhdHRyaWJ1dGUgcHJvcCAke2F0dHJpYnV0ZU5hbWV9YCk7XG4gICAgICB9XG4gICAgICAvLyBjb25zdCBidWZmZXIgPSBidWZmZXJNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICAvLyBUT0RPIC0gY2hlY2sgYnVmZmVyIHR5cGVcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgdGhlIGJ1ZmZlcnMgZm9yIHRoZSBzdXBwbGllZCBhdHRyaWJ1dGVzXG4gIC8vIFVwZGF0ZSBhdHRyaWJ1dGUgYnVmZmVycyBmcm9tIGFueSBhdHRyaWJ1dGVzIGluIHByb3BzXG4gIC8vIERldGFjaCBhbnkgcHJldmlvdXNseSBzZXQgYnVmZmVycywgbWFya2luZyBhbGxcbiAgLy8gQXR0cmlidXRlcyBmb3IgYXV0byBhbGxvY2F0aW9uXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVyTWFwKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIG51bUluc3RhbmNlc30gPSB0aGlzO1xuXG4gICAgLy8gQ29weSB0aGUgcmVmcyBvZiBhbnkgc3VwcGxpZWQgYnVmZmVycyBpbiB0aGUgcHJvcHNcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlck1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gZmFsc2U7XG4gICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBwcm9wZXJ0aWVzIG11c3QgYmUgb2YgdHlwZSBGbG9hdDMyQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLmF1dG8gJiYgYnVmZmVyLmxlbmd0aCA8PSBudW1JbnN0YW5jZXMgKiBhdHRyaWJ1dGUuc2l6ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHByb3AgYXJyYXkgbXVzdCBtYXRjaCBsZW5ndGggYW5kIHNpemUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgIT09IGJ1ZmZlcikge1xuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGJ1ZmZlcjtcbiAgICAgICAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8qIENoZWNrcyB0aGF0IHR5cGVkIGFycmF5cyBmb3IgYXR0cmlidXRlcyBhcmUgYmlnIGVub3VnaFxuICAgKiBzZXRzIGFsbG9jIGZsYWcgaWYgbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgYW55IHVwZGF0ZXMgYXJlIG5lZWRlZFxuICAgKi9cbiAgX2FuYWx5emVCdWZmZXJzKHtudW1JbnN0YW5jZXN9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBhc3NlcnQobnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpO1xuXG4gICAgLy8gVHJhY2sgd2hldGhlciBhbnkgYWxsb2NhdGlvbnMgb3IgdXBkYXRlcyBhcmUgbmVlZGVkXG4gICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIpIHtcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byByZWFsbG9jYXRlIHRoZSBhdHRyaWJ1dGUncyB0eXBlZCBhcnJheT9cbiAgICAgICAgY29uc3QgbmVlZHNBbGxvYyA9XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplIDwgbnVtSW5zdGFuY2VzO1xuICAgICAgICBpZiAobmVlZHNBbGxvYyAmJiBhdHRyaWJ1dGUudXBkYXRlKSB7XG4gICAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSB0cnVlO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lZWRzVXBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENhbGxzIHVwZGF0ZSBvbiBhbnkgYnVmZmVycyB0aGF0IG5lZWQgdXBkYXRlXG4gICAqIFRPRE8/IC0gSWYgYXBwIHN1cHBsaWVkIGFsbCBhdHRyaWJ1dGVzLCBubyBuZWVkIHRvIGl0ZXJhdGUgb3ZlciBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJ1ZmZlcnMgPSB7fSAtIHByZS1hbGxvY2F0ZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX3VwZGF0ZUJ1ZmZlcnMoe251bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcblxuICAgIC8vIEFsbG9jYXRlIGF0IGxlYXN0IG9uZSBlbGVtZW50IHRvIGVuc3VyZSBhIHZhbGlkIGJ1ZmZlclxuICAgIGNvbnN0IGFsbG9jQ291bnQgPSBNYXRoLm1heChudW1JbnN0YW5jZXMsIDEpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIC8vIEFsbG9jYXRlIGEgbmV3IHR5cGVkIGFycmF5IGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc0FsbG9jKSB7XG4gICAgICAgIGNvbnN0IEFycmF5VHlwZSA9IGF0dHJpYnV0ZS50eXBlIHx8IEZsb2F0MzJBcnJheTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEFycmF5VHlwZShhdHRyaWJ1dGUuc2l6ZSAqIGFsbG9jQ291bnQpO1xuICAgICAgICB0aGlzLm9uTG9nKDIsIGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gYWxsb2NhdGVkICR7YWxsb2NDb3VudH1gKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbCB1cGRhdGVyIGZ1bmN0aW9uIGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICBjb25zdCB7dXBkYXRlfSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMub25Mb2coMiwgYCR7dGhpcy5pZH06JHthdHRyaWJ1dGVOYW1lfSB1cGRhdGluZyAke251bUluc3RhbmNlc31gKTtcbiAgICAgICAgICB1cGRhdGUuY2FsbChjb250ZXh0LCBhdHRyaWJ1dGUsIHtkYXRhLCBwcm9wcywgbnVtSW5zdGFuY2VzfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkxvZygyLCBgJHt0aGlzLmlkfToke2F0dHJpYnV0ZU5hbWV9IG1pc3NpbmcgdXBkYXRlIGZ1bmN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbGxvY2VkSW5zdGFuY2VzID0gYWxsb2NDb3VudDtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG59XG4iXX0=