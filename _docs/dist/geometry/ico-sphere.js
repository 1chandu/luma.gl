'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.IcoSphereGeometry = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _math = require('../math');

var _geometry = require('../core/geometry');

var _geometry2 = _interopRequireDefault(_geometry);

var _model = require('../core/model');

var _model2 = _interopRequireDefault(_model);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable comma-spacing, max-statements, complexity */

function noop() {}

var ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
var ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];

var IcoSphereGeometry = exports.IcoSphereGeometry = function (_Geometry) {
  _inherits(IcoSphereGeometry, _Geometry);

  function IcoSphereGeometry() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$iterations = _ref.iterations;
    var iterations = _ref$iterations === undefined ? 0 : _ref$iterations;
    var _ref$onAddVertex = _ref.onAddVertex;
    var onAddVertex = _ref$onAddVertex === undefined ? noop : _ref$onAddVertex;

    var opts = _objectWithoutProperties(_ref, ['iterations', 'onAddVertex']);

    _classCallCheck(this, IcoSphereGeometry);

    var PI = Math.PI;
    var PI2 = PI * 2;

    var positions = [].concat(ICO_POSITIONS);
    var indices = [].concat(ICO_INDICES);

    positions.push();
    indices.push();

    var getMiddlePoint = function () {
      var pointMemo = {};

      return function (i1, i2) {
        i1 *= 3;
        i2 *= 3;
        var mini = i1 < i2 ? i1 : i2;
        var maxi = i1 > i2 ? i1 : i2;
        var key = mini + '|' + maxi;

        if (key in pointMemo) {
          return pointMemo[key];
        }

        var x1 = positions[i1];
        var y1 = positions[i1 + 1];
        var z1 = positions[i1 + 2];
        var x2 = positions[i2];
        var y2 = positions[i2 + 1];
        var z2 = positions[i2 + 2];
        var xm = (x1 + x2) / 2;
        var ym = (y1 + y2) / 2;
        var zm = (z1 + z2) / 2;
        var len = Math.sqrt(xm * xm + ym * ym + zm * zm);

        xm /= len;
        ym /= len;
        zm /= len;

        positions.push(xm, ym, zm);

        return pointMemo[key] = positions.length / 3 - 1;
      };
    }();

    for (var i = 0; i < iterations; i++) {
      var indices2 = [];
      for (var j = 0; j < indices.length; j += 3) {
        var a = getMiddlePoint(indices[j + 0], indices[j + 1]);
        var b = getMiddlePoint(indices[j + 1], indices[j + 2]);
        var c = getMiddlePoint(indices[j + 2], indices[j + 0]);

        indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
      }
      indices = indices2;
    }

    // Calculate texCoords and normals
    var normals = new Array(indices.length * 3);
    var texCoords = new Array(indices.length * 2);

    var l = indices.length;
    for (var _i = l - 3; _i >= 0; _i -= 3) {
      var i1 = indices[_i + 0];
      var i2 = indices[_i + 1];
      var i3 = indices[_i + 2];
      var in1 = i1 * 3;
      var in2 = i2 * 3;
      var in3 = i3 * 3;
      var iu1 = i1 * 2;
      var iu2 = i2 * 2;
      var iu3 = i3 * 2;
      var x1 = positions[in1 + 0];
      var y1 = positions[in1 + 1];
      var z1 = positions[in1 + 2];
      var theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
      var phi1 = Math.atan2(y1, x1) + PI;
      var v1 = theta1 / PI;
      var u1 = 1 - phi1 / PI2;
      var x2 = positions[in2 + 0];
      var y2 = positions[in2 + 1];
      var z2 = positions[in2 + 2];
      var theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
      var phi2 = Math.atan2(y2, x2) + PI;
      var v2 = theta2 / PI;
      var u2 = 1 - phi2 / PI2;
      var x3 = positions[in3 + 0];
      var y3 = positions[in3 + 1];
      var z3 = positions[in3 + 2];
      var theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
      var phi3 = Math.atan2(y3, x3) + PI;
      var v3 = theta3 / PI;
      var u3 = 1 - phi3 / PI2;
      var vec1 = [x3 - x2, y3 - y2, z3 - z2];
      var vec2 = [x1 - x2, y1 - y2, z1 - z2];
      var normal = _math.Vec3.cross(vec1, vec2).$unit();
      var newIndex = void 0;

      if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {

        positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v1;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;

        positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v2;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;

        positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v3;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
      }

      normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
      normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
      normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;

      texCoords[iu1 + 0] = u1;
      texCoords[iu1 + 1] = v1;

      texCoords[iu2 + 0] = u2;
      texCoords[iu2 + 1] = v2;

      texCoords[iu3 + 0] = u3;
      texCoords[iu3 + 1] = v3;
    }

    return _possibleConstructorReturn(this, (IcoSphereGeometry.__proto__ || Object.getPrototypeOf(IcoSphereGeometry)).call(this, _extends({}, opts, {
      attributes: {
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        texCoords: new Float32Array(texCoords),
        indices: new Uint16Array(indices)
      }
    })));
  }

  return IcoSphereGeometry;
}(_geometry2.default);

var IcoSphere = function (_Model) {
  _inherits(IcoSphere, _Model);

  function IcoSphere() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, IcoSphere);

    return _possibleConstructorReturn(this, (IcoSphere.__proto__ || Object.getPrototypeOf(IcoSphere)).call(this, _extends({}, opts, {
      geometry: new IcoSphereGeometry(opts)
    })));
  }

  return IcoSphere;
}(_model2.default);

exports.default = IcoSphere;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9pY28tc3BoZXJlLmpzIl0sIm5hbWVzIjpbIm5vb3AiLCJJQ09fUE9TSVRJT05TIiwiSUNPX0lORElDRVMiLCJJY29TcGhlcmVHZW9tZXRyeSIsIml0ZXJhdGlvbnMiLCJvbkFkZFZlcnRleCIsIm9wdHMiLCJQSSIsIk1hdGgiLCJQSTIiLCJwb3NpdGlvbnMiLCJpbmRpY2VzIiwicHVzaCIsImdldE1pZGRsZVBvaW50IiwicG9pbnRNZW1vIiwiaTEiLCJpMiIsIm1pbmkiLCJtYXhpIiwia2V5IiwieDEiLCJ5MSIsInoxIiwieDIiLCJ5MiIsInoyIiwieG0iLCJ5bSIsInptIiwibGVuIiwic3FydCIsImxlbmd0aCIsImkiLCJpbmRpY2VzMiIsImoiLCJhIiwiYiIsImMiLCJub3JtYWxzIiwiQXJyYXkiLCJ0ZXhDb29yZHMiLCJsIiwiaTMiLCJpbjEiLCJpbjIiLCJpbjMiLCJpdTEiLCJpdTIiLCJpdTMiLCJ0aGV0YTEiLCJhY29zIiwicGhpMSIsImF0YW4yIiwidjEiLCJ1MSIsInRoZXRhMiIsInBoaTIiLCJ2MiIsInUyIiwieDMiLCJ5MyIsInozIiwidGhldGEzIiwicGhpMyIsInYzIiwidTMiLCJ2ZWMxIiwidmVjMiIsIm5vcm1hbCIsImNyb3NzIiwiJHVuaXQiLCJuZXdJbmRleCIsIngiLCJ5IiwieiIsImF0dHJpYnV0ZXMiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIkljb1NwaGVyZSIsImdlb21ldHJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBOztBQUVBLFNBQVNBLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsSUFBTUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFGLEVBQUksQ0FBSixFQUFNLENBQU4sRUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBa0IsQ0FBbEIsRUFBb0IsQ0FBQyxDQUFyQixFQUF3QixDQUF4QixF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NkQsOElBMEt6RDFELElBMUt5RDtBQTJLNURxRSxrQkFBWTtBQUNWakUsbUJBQVcsSUFBSWtFLFlBQUosQ0FBaUJsRSxTQUFqQixDQUREO0FBRVY0QixpQkFBUyxJQUFJc0MsWUFBSixDQUFpQnRDLE9BQWpCLENBRkM7QUFHVkUsbUJBQVcsSUFBSW9DLFlBQUosQ0FBaUJwQyxTQUFqQixDQUhEO0FBSVY3QixpQkFBUyxJQUFJa0UsV0FBSixDQUFnQmxFLE9BQWhCO0FBSkM7QUEzS2dEO0FBa0wvRDs7Ozs7SUFHa0JtRSxTOzs7QUFDbkIsdUJBQXVCO0FBQUEsUUFBWHhFLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSw4SEFFaEJBLElBRmdCO0FBR25CeUUsZ0JBQVUsSUFBSTVFLGlCQUFKLENBQXNCRyxJQUF0QjtBQUhTO0FBS3RCOzs7OztrQkFOa0J3RSxTIiwiZmlsZSI6Imljby1zcGhlcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1ZlYzN9IGZyb20gJy4uL21hdGgnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL2NvcmUvZ2VvbWV0cnknO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uL2NvcmUvbW9kZWwnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLCBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgSUNPX1BPU0lUSU9OUyA9IFstMSwwLDAsIDAsMSwwLCAwLDAsLTEsIDAsMCwxLCAwLC0xLDAsIDEsMCwwXTtcbmNvbnN0IElDT19JTkRJQ0VTID0gWzMsNCw1LDMsNSwxLDMsMSwwLDMsMCw0LDQsMCwyLDQsMiw1LDIsMCwxLDUsMiwxXTtcblxuZXhwb3J0IGNsYXNzIEljb1NwaGVyZUdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuXG4gIGNvbnN0cnVjdG9yKHtpdGVyYXRpb25zID0gMCwgb25BZGRWZXJ0ZXggPSBub29wLCAuLi5vcHRzfSA9IHt9KSB7XG4gICAgY29uc3QgUEkgPSBNYXRoLlBJO1xuICAgIGNvbnN0IFBJMiA9IFBJICogMjtcblxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFsuLi5JQ09fUE9TSVRJT05TXTtcbiAgICBsZXQgaW5kaWNlcyA9IFsuLi5JQ09fSU5ESUNFU107XG5cbiAgICBwb3NpdGlvbnMucHVzaCgpO1xuICAgIGluZGljZXMucHVzaCgpO1xuXG4gICAgY29uc3QgZ2V0TWlkZGxlUG9pbnQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgcG9pbnRNZW1vID0ge307XG5cbiAgICAgIHJldHVybiAoaTEsIGkyKSA9PiB7XG4gICAgICAgIGkxICo9IDM7XG4gICAgICAgIGkyICo9IDM7XG4gICAgICAgIGNvbnN0IG1pbmkgPSBpMSA8IGkyID8gaTEgOiBpMjtcbiAgICAgICAgY29uc3QgbWF4aSA9IGkxID4gaTIgPyBpMSA6IGkyO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHttaW5pfXwke21heGl9YDtcblxuICAgICAgICBpZiAoa2V5IGluIHBvaW50TWVtbykge1xuICAgICAgICAgIHJldHVybiBwb2ludE1lbW9ba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHgxID0gcG9zaXRpb25zW2kxXTtcbiAgICAgICAgY29uc3QgeTEgPSBwb3NpdGlvbnNbaTEgKyAxXTtcbiAgICAgICAgY29uc3QgejEgPSBwb3NpdGlvbnNbaTEgKyAyXTtcbiAgICAgICAgY29uc3QgeDIgPSBwb3NpdGlvbnNbaTJdO1xuICAgICAgICBjb25zdCB5MiA9IHBvc2l0aW9uc1tpMiArIDFdO1xuICAgICAgICBjb25zdCB6MiA9IHBvc2l0aW9uc1tpMiArIDJdO1xuICAgICAgICBsZXQgeG0gPSAoeDEgKyB4MikgLyAyO1xuICAgICAgICBsZXQgeW0gPSAoeTEgKyB5MikgLyAyO1xuICAgICAgICBsZXQgem0gPSAoejEgKyB6MikgLyAyO1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQoeG0gKiB4bSArIHltICogeW0gKyB6bSAqIHptKTtcblxuICAgICAgICB4bSAvPSBsZW47XG4gICAgICAgIHltIC89IGxlbjtcbiAgICAgICAgem0gLz0gbGVuO1xuXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHhtLCB5bSwgem0pO1xuXG4gICAgICAgIHJldHVybiAocG9pbnRNZW1vW2tleV0gPSAocG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxKSk7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgY29uc3QgaW5kaWNlczIgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kaWNlcy5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICBjb25zdCBhID0gZ2V0TWlkZGxlUG9pbnQoaW5kaWNlc1tqICsgMF0sIGluZGljZXNbaiArIDFdKTtcbiAgICAgICAgY29uc3QgYiA9IGdldE1pZGRsZVBvaW50KGluZGljZXNbaiArIDFdLCBpbmRpY2VzW2ogKyAyXSk7XG4gICAgICAgIGNvbnN0IGMgPSBnZXRNaWRkbGVQb2ludChpbmRpY2VzW2ogKyAyXSwgaW5kaWNlc1tqICsgMF0pO1xuXG4gICAgICAgIGluZGljZXMyLnB1c2goXG4gICAgICAgICAgYywgaW5kaWNlc1tqICsgMF0sIGEsXG4gICAgICAgICAgYSwgaW5kaWNlc1tqICsgMV0sIGIsXG4gICAgICAgICAgYiwgaW5kaWNlc1tqICsgMl0sIGMsXG4gICAgICAgICAgYSwgYiwgYyk7XG4gICAgICB9XG4gICAgICBpbmRpY2VzID0gaW5kaWNlczI7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRleENvb3JkcyBhbmQgbm9ybWFsc1xuICAgIGNvbnN0IG5vcm1hbHMgPSBuZXcgQXJyYXkoaW5kaWNlcy5sZW5ndGggKiAzKTtcbiAgICBjb25zdCB0ZXhDb29yZHMgPSBuZXcgQXJyYXkoaW5kaWNlcy5sZW5ndGggKiAyKTtcblxuICAgIGNvbnN0IGwgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbCAtIDM7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICBjb25zdCBpMSA9IGluZGljZXNbaSArIDBdO1xuICAgICAgY29uc3QgaTIgPSBpbmRpY2VzW2kgKyAxXTtcbiAgICAgIGNvbnN0IGkzID0gaW5kaWNlc1tpICsgMl07XG4gICAgICBjb25zdCBpbjEgPSBpMSAqIDM7XG4gICAgICBjb25zdCBpbjIgPSBpMiAqIDM7XG4gICAgICBjb25zdCBpbjMgPSBpMyAqIDM7XG4gICAgICBjb25zdCBpdTEgPSBpMSAqIDI7XG4gICAgICBjb25zdCBpdTIgPSBpMiAqIDI7XG4gICAgICBjb25zdCBpdTMgPSBpMyAqIDI7XG4gICAgICBjb25zdCB4MSA9IHBvc2l0aW9uc1tpbjEgKyAwXTtcbiAgICAgIGNvbnN0IHkxID0gcG9zaXRpb25zW2luMSArIDFdO1xuICAgICAgY29uc3QgejEgPSBwb3NpdGlvbnNbaW4xICsgMl07XG4gICAgICBjb25zdCB0aGV0YTEgPSBNYXRoLmFjb3MoejEgLyBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEgKyB6MSAqIHoxKSk7XG4gICAgICBjb25zdCBwaGkxID0gTWF0aC5hdGFuMih5MSwgeDEpICsgUEk7XG4gICAgICBjb25zdCB2MSA9IHRoZXRhMSAvIFBJO1xuICAgICAgY29uc3QgdTEgPSAxIC0gcGhpMSAvIFBJMjtcbiAgICAgIGNvbnN0IHgyID0gcG9zaXRpb25zW2luMiArIDBdO1xuICAgICAgY29uc3QgeTIgPSBwb3NpdGlvbnNbaW4yICsgMV07XG4gICAgICBjb25zdCB6MiA9IHBvc2l0aW9uc1tpbjIgKyAyXTtcbiAgICAgIGNvbnN0IHRoZXRhMiA9IE1hdGguYWNvcyh6MiAvIE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5MiArIHoyICogejIpKTtcbiAgICAgIGNvbnN0IHBoaTIgPSBNYXRoLmF0YW4yKHkyLCB4MikgKyBQSTtcbiAgICAgIGNvbnN0IHYyID0gdGhldGEyIC8gUEk7XG4gICAgICBjb25zdCB1MiA9IDEgLSBwaGkyIC8gUEkyO1xuICAgICAgY29uc3QgeDMgPSBwb3NpdGlvbnNbaW4zICsgMF07XG4gICAgICBjb25zdCB5MyA9IHBvc2l0aW9uc1tpbjMgKyAxXTtcbiAgICAgIGNvbnN0IHozID0gcG9zaXRpb25zW2luMyArIDJdO1xuICAgICAgY29uc3QgdGhldGEzID0gTWF0aC5hY29zKHozIC8gTWF0aC5zcXJ0KHgzICogeDMgKyB5MyAqIHkzICsgejMgKiB6MykpO1xuICAgICAgY29uc3QgcGhpMyA9IE1hdGguYXRhbjIoeTMsIHgzKSArIFBJO1xuICAgICAgY29uc3QgdjMgPSB0aGV0YTMgLyBQSTtcbiAgICAgIGNvbnN0IHUzID0gMSAtIHBoaTMgLyBQSTI7XG4gICAgICBjb25zdCB2ZWMxID0gW1xuICAgICAgICB4MyAtIHgyLFxuICAgICAgICB5MyAtIHkyLFxuICAgICAgICB6MyAtIHoyXG4gICAgICBdO1xuICAgICAgY29uc3QgdmVjMiA9IFtcbiAgICAgICAgeDEgLSB4MixcbiAgICAgICAgeTEgLSB5MixcbiAgICAgICAgejEgLSB6MlxuICAgICAgXTtcbiAgICAgIGNvbnN0IG5vcm1hbCA9IFZlYzMuY3Jvc3ModmVjMSwgdmVjMikuJHVuaXQoKTtcbiAgICAgIGxldCBuZXdJbmRleDtcblxuICAgICAgaWYgKCh1MSA9PT0gMCB8fCB1MiA9PT0gMCB8fCB1MyA9PT0gMCkgJiZcbiAgICAgICAgICAodTEgPT09IDAgfHwgdTEgPiAwLjUpICYmXG4gICAgICAgICAgICAodTIgPT09IDAgfHwgdTIgPiAwLjUpICYmXG4gICAgICAgICAgICAgICh1MyA9PT0gMCB8fCB1MyA+IDAuNSkpIHtcblxuICAgICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgICBwb3NpdGlvbnNbaW4xICsgMF0sXG4gICAgICAgICAgcG9zaXRpb25zW2luMSArIDFdLFxuICAgICAgICAgIHBvc2l0aW9uc1tpbjEgKyAyXVxuICAgICAgICApO1xuICAgICAgICBuZXdJbmRleCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKG5ld0luZGV4KTtcbiAgICAgICAgdGV4Q29vcmRzW25ld0luZGV4ICogMiArIDBdID0gMTtcbiAgICAgICAgdGV4Q29vcmRzW25ld0luZGV4ICogMiArIDFdID0gdjE7XG4gICAgICAgIG5vcm1hbHNbbmV3SW5kZXggKiAzICsgMF0gPSBub3JtYWwueDtcbiAgICAgICAgbm9ybWFsc1tuZXdJbmRleCAqIDMgKyAxXSA9IG5vcm1hbC55O1xuICAgICAgICBub3JtYWxzW25ld0luZGV4ICogMyArIDJdID0gbm9ybWFsLno7XG5cbiAgICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgICAgcG9zaXRpb25zW2luMiArIDBdLFxuICAgICAgICAgIHBvc2l0aW9uc1tpbjIgKyAxXSxcbiAgICAgICAgICBwb3NpdGlvbnNbaW4yICsgMl1cbiAgICAgICAgKTtcbiAgICAgICAgbmV3SW5kZXggPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7XG4gICAgICAgIGluZGljZXMucHVzaChuZXdJbmRleCk7XG4gICAgICAgIHRleENvb3Jkc1tuZXdJbmRleCAqIDIgKyAwXSA9IDE7XG4gICAgICAgIHRleENvb3Jkc1tuZXdJbmRleCAqIDIgKyAxXSA9IHYyO1xuICAgICAgICBub3JtYWxzW25ld0luZGV4ICogMyArIDBdID0gbm9ybWFsLng7XG4gICAgICAgIG5vcm1hbHNbbmV3SW5kZXggKiAzICsgMV0gPSBub3JtYWwueTtcbiAgICAgICAgbm9ybWFsc1tuZXdJbmRleCAqIDMgKyAyXSA9IG5vcm1hbC56O1xuXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgIHBvc2l0aW9uc1tpbjMgKyAwXSxcbiAgICAgICAgICBwb3NpdGlvbnNbaW4zICsgMV0sXG4gICAgICAgICAgcG9zaXRpb25zW2luMyArIDJdXG4gICAgICAgICk7XG4gICAgICAgIG5ld0luZGV4ID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxO1xuICAgICAgICBpbmRpY2VzLnB1c2gobmV3SW5kZXgpO1xuICAgICAgICB0ZXhDb29yZHNbbmV3SW5kZXggKiAyICsgMF0gPSAxO1xuICAgICAgICB0ZXhDb29yZHNbbmV3SW5kZXggKiAyICsgMV0gPSB2MztcbiAgICAgICAgbm9ybWFsc1tuZXdJbmRleCAqIDMgKyAwXSA9IG5vcm1hbC54O1xuICAgICAgICBub3JtYWxzW25ld0luZGV4ICogMyArIDFdID0gbm9ybWFsLnk7XG4gICAgICAgIG5vcm1hbHNbbmV3SW5kZXggKiAzICsgMl0gPSBub3JtYWwuejtcbiAgICAgIH1cblxuICAgICAgbm9ybWFsc1tpbjEgKyAwXSA9IG5vcm1hbHNbaW4yICsgMF0gPSBub3JtYWxzW2luMyArIDBdID0gbm9ybWFsLng7XG4gICAgICBub3JtYWxzW2luMSArIDFdID0gbm9ybWFsc1tpbjIgKyAxXSA9IG5vcm1hbHNbaW4zICsgMV0gPSBub3JtYWwueTtcbiAgICAgIG5vcm1hbHNbaW4xICsgMl0gPSBub3JtYWxzW2luMiArIDJdID0gbm9ybWFsc1tpbjMgKyAyXSA9IG5vcm1hbC56O1xuXG4gICAgICB0ZXhDb29yZHNbaXUxICsgMF0gPSB1MTtcbiAgICAgIHRleENvb3Jkc1tpdTEgKyAxXSA9IHYxO1xuXG4gICAgICB0ZXhDb29yZHNbaXUyICsgMF0gPSB1MjtcbiAgICAgIHRleENvb3Jkc1tpdTIgKyAxXSA9IHYyO1xuXG4gICAgICB0ZXhDb29yZHNbaXUzICsgMF0gPSB1MztcbiAgICAgIHRleENvb3Jkc1tpdTMgKyAxXSA9IHYzO1xuICAgIH1cblxuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpLFxuICAgICAgICBub3JtYWxzOiBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbHMpLFxuICAgICAgICB0ZXhDb29yZHM6IG5ldyBGbG9hdDMyQXJyYXkodGV4Q29vcmRzKSxcbiAgICAgICAgaW5kaWNlczogbmV3IFVpbnQxNkFycmF5KGluZGljZXMpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvU3BoZXJlIGV4dGVuZHMgTW9kZWwge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBJY29TcGhlcmVHZW9tZXRyeShvcHRzKVxuICAgIH0pO1xuICB9XG59XG4iXX0=