'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GL_BUFFER_USAGE = exports.BUFFER_USAGE = exports.GL_TARGETS = exports.TARGETS = exports.GL_DRAW_MODES = exports.DRAW_MODES = exports.GL_INDEX_TYPES = exports.INDEX_TYPES = undefined;

var _webglTypes = require('./webgl-types');

Object.keys(_webglTypes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _webglTypes[key];
    }
  });
});
exports.isIndexType = isIndexType;
exports.isGLIndexType = isGLIndexType;
exports.assertIndexType = assertIndexType;
exports.isDrawMode = isDrawMode;
exports.isGLDrawMode = isGLDrawMode;
exports.assertDrawMode = assertDrawMode;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// INDEX TYPES

// For drawElements, size of indices
// Helper definitions for validation of webgl parameters
/* eslint-disable no-inline-comments, max-len */
var INDEX_TYPES = exports.INDEX_TYPES = ['UNSIGNED_BYTE', 'UNSIGNED_SHORT'];
var GL_INDEX_TYPES = exports.GL_INDEX_TYPES = function GL_INDEX_TYPES(gl) {
  return INDEX_TYPES.map(function (constant) {
    return gl[constant];
  });
};

function isIndexType(type) {
  return INDEX_TYPES.indexOf(type) !== -1;
}
function isGLIndexType(gl, glType) {
  return GL_INDEX_TYPES(gl).indexOf(glType) !== -1;
}

function assertIndexType(gl, glType, source) {
  (0, _assert2.default)(isGLIndexType(gl, glType), 'Bad index type gl.' + getKey(gl, glType) + ' ' + source);
}

// DRAW MODES

var DRAW_MODES = exports.DRAW_MODES = ['POINTS', 'LINE_STRIP', 'LINE_LOOP', 'LINES', 'TRIANGLE_STRIP', 'TRIANGLE_FAN', 'TRIANGLES'];
var GL_DRAW_MODES = exports.GL_DRAW_MODES = function GL_DRAW_MODES(gl) {
  return DRAW_MODES.map(function (constant) {
    return gl[constant];
  });
};

function isDrawMode(mode) {
  return DRAW_MODES.indexOf(mode) !== -1;
}
function isGLDrawMode(gl, glMode) {
  return GL_DRAW_MODES(gl).indexOf(glMode) !== -1;
}

function assertDrawMode(gl, glType, source) {
  (0, _assert2.default)(isGLDrawMode(gl, glType), 'Bad draw mode gl.' + getKey(gl, glType) + ' ' + source);
}

// TARGET TYPES

var TARGETS = exports.TARGETS = ['ARRAY_BUFFER', // vertex attributes (e.g. vertex/texture coords or color)
'ELEMENT_ARRAY_BUFFER', // Buffer used for element indices.
// For WebGL 2 contexts
'COPY_READ_BUFFER', // Buffer for copying from one buffer object to another
'COPY_WRITE_BUFFER', // Buffer for copying from one buffer object to another
'TRANSFORM_FEEDBACK_BUFFER', // Buffer for transform feedback operations
'UNIFORM_BUFFER', // Buffer used for storing uniform blocks
'PIXEL_PACK_BUFFER', // Buffer used for pixel transfer operations
'PIXEL_UNPACK_BUFFER' // Buffer used for pixel transfer operations
];

var GL_TARGETS = exports.GL_TARGETS = function GL_TARGETS(gl) {
  return TARGETS.map(function (constant) {
    return gl[constant];
  }).filter(function (constant) {
    return constant;
  });
};

// USAGE TYPES

var BUFFER_USAGE = exports.BUFFER_USAGE = ['STATIC_DRAW', // Buffer used often and not change often. Contents are written to the buffer, but not read.
'DYNAMIC_DRAW', // Buffer used often and change often. Contents are written to the buffer, but not read.
'STREAM_DRAW', // Buffer not used often. Contents are written to the buffer, but not read.
// For WebGL 2 contexts
'STATIC_READ', // Buffer used often and not change often. Contents are read from the buffer, but not written.
'DYNAMIC_READ', // Buffer used often and change often. Contents are read from the buffer, but not written.
'STREAM_READ', // Contents of the buffer are likely to not be used often. Contents are read from the buffer, but not written.
'STATIC_COPY', // Buffer used often and not change often. Contents are neither written or read by the user.
'DYNAMIC_COPY', // Buffer used often and change often. Contents are neither written or read by the user.
'STREAM_COPY' // Buffer used often and not change often. Contents are neither written or read by the user.
];

var GL_BUFFER_USAGE = exports.GL_BUFFER_USAGE = function GL_BUFFER_USAGE(gl) {
  return BUFFER_USAGE.map(function (constant) {
    return gl[constant];
  }).filter(function (constant) {
    return constant;
  });
};

function getKey(gl, value) {
  for (var key in gl) {
    if (gl[key] === value) {
      return key;
    }
  }
  return String(value);
}
//# sourceMappingURL=data:application/json;base64,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VjBCLENBVVo7QUFWWSxDQUFyQjs7QUFhQSxJQUFNLDRDQUNYLFNBRFcsZUFDWDtBQUFBLFNBQU0sYUFBYSxHQUFiLENBQWlCO0FBQUEsV0FBWSxHQUFHLFFBQUgsQ0FBWjtBQUFBLEdBQWpCLEVBQTJDLE1BQTNDLENBQWtEO0FBQUEsV0FBWSxRQUFaO0FBQUEsR0FBbEQsQ0FBTjtBQUFBLENBREs7O0FBR1AsU0FBUyxNQUFULENBQWdCLEVBQWhCLEVBQW9CLEtBQXBCLEVBQTJCO0FBQ3pCLE9BQUssSUFBTSxHQUFYLElBQWtCLEVBQWxCLEVBQXNCO0FBQ3BCLFFBQUksR0FBRyxHQUFILE1BQVksS0FBaEIsRUFBdUI7QUFDckIsYUFBTyxHQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sT0FBTyxLQUFQLENBQVA7QUFDRCIsImZpbGUiOiJ0eXBlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEhlbHBlciBkZWZpbml0aW9ucyBmb3IgdmFsaWRhdGlvbiBvZiB3ZWJnbCBwYXJhbWV0ZXJzXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbmxpbmUtY29tbWVudHMsIG1heC1sZW4gKi9cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmV4cG9ydCAqIGZyb20gJy4vd2ViZ2wtdHlwZXMnO1xuXG4vLyBJTkRFWCBUWVBFU1xuXG4vLyBGb3IgZHJhd0VsZW1lbnRzLCBzaXplIG9mIGluZGljZXNcbmV4cG9ydCBjb25zdCBJTkRFWF9UWVBFUyA9IFsnVU5TSUdORURfQllURScsICdVTlNJR05FRF9TSE9SVCddO1xuZXhwb3J0IGNvbnN0IEdMX0lOREVYX1RZUEVTID0gZ2wgPT4gSU5ERVhfVFlQRVMubWFwKGNvbnN0YW50ID0+IGdsW2NvbnN0YW50XSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luZGV4VHlwZSh0eXBlKSB7XG4gIHJldHVybiBJTkRFWF9UWVBFUy5pbmRleE9mKHR5cGUpICE9PSAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0dMSW5kZXhUeXBlKGdsLCBnbFR5cGUpIHtcbiAgcmV0dXJuIEdMX0lOREVYX1RZUEVTKGdsKS5pbmRleE9mKGdsVHlwZSkgIT09IC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SW5kZXhUeXBlKGdsLCBnbFR5cGUsIHNvdXJjZSkge1xuICBhc3NlcnQoaXNHTEluZGV4VHlwZShnbCwgZ2xUeXBlKSxcbiAgICBgQmFkIGluZGV4IHR5cGUgZ2wuJHtnZXRLZXkoZ2wsIGdsVHlwZSl9ICR7c291cmNlfWApO1xufVxuXG4vLyBEUkFXIE1PREVTXG5cbmV4cG9ydCBjb25zdCBEUkFXX01PREVTID0gW1xuICAnUE9JTlRTJywgJ0xJTkVfU1RSSVAnLCAnTElORV9MT09QJywgJ0xJTkVTJyxcbiAgJ1RSSUFOR0xFX1NUUklQJywgJ1RSSUFOR0xFX0ZBTicsICdUUklBTkdMRVMnXG5dO1xuZXhwb3J0IGNvbnN0IEdMX0RSQVdfTU9ERVMgPSBnbCA9PiBEUkFXX01PREVTLm1hcChjb25zdGFudCA9PiBnbFtjb25zdGFudF0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEcmF3TW9kZShtb2RlKSB7XG4gIHJldHVybiBEUkFXX01PREVTLmluZGV4T2YobW9kZSkgIT09IC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzR0xEcmF3TW9kZShnbCwgZ2xNb2RlKSB7XG4gIHJldHVybiBHTF9EUkFXX01PREVTKGdsKS5pbmRleE9mKGdsTW9kZSkgIT09IC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RHJhd01vZGUoZ2wsIGdsVHlwZSwgc291cmNlKSB7XG4gIGFzc2VydChpc0dMRHJhd01vZGUoZ2wsIGdsVHlwZSksXG4gICAgYEJhZCBkcmF3IG1vZGUgZ2wuJHtnZXRLZXkoZ2wsIGdsVHlwZSl9ICR7c291cmNlfWApO1xufVxuXG4vLyBUQVJHRVQgVFlQRVNcblxuZXhwb3J0IGNvbnN0IFRBUkdFVFMgPSBbXG4gICdBUlJBWV9CVUZGRVInLCAvLyB2ZXJ0ZXggYXR0cmlidXRlcyAoZS5nLiB2ZXJ0ZXgvdGV4dHVyZSBjb29yZHMgb3IgY29sb3IpXG4gICdFTEVNRU5UX0FSUkFZX0JVRkZFUicsIC8vIEJ1ZmZlciB1c2VkIGZvciBlbGVtZW50IGluZGljZXMuXG4gIC8vIEZvciBXZWJHTCAyIGNvbnRleHRzXG4gICdDT1BZX1JFQURfQlVGRkVSJywgLy8gQnVmZmVyIGZvciBjb3B5aW5nIGZyb20gb25lIGJ1ZmZlciBvYmplY3QgdG8gYW5vdGhlclxuICAnQ09QWV9XUklURV9CVUZGRVInLCAvLyBCdWZmZXIgZm9yIGNvcHlpbmcgZnJvbSBvbmUgYnVmZmVyIG9iamVjdCB0byBhbm90aGVyXG4gICdUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSJywgLy8gQnVmZmVyIGZvciB0cmFuc2Zvcm0gZmVlZGJhY2sgb3BlcmF0aW9uc1xuICAnVU5JRk9STV9CVUZGRVInLCAvLyBCdWZmZXIgdXNlZCBmb3Igc3RvcmluZyB1bmlmb3JtIGJsb2Nrc1xuICAnUElYRUxfUEFDS19CVUZGRVInLCAvLyBCdWZmZXIgdXNlZCBmb3IgcGl4ZWwgdHJhbnNmZXIgb3BlcmF0aW9uc1xuICAnUElYRUxfVU5QQUNLX0JVRkZFUicgLy8gQnVmZmVyIHVzZWQgZm9yIHBpeGVsIHRyYW5zZmVyIG9wZXJhdGlvbnNcbl07XG5cbmV4cG9ydCBjb25zdCBHTF9UQVJHRVRTID1cbiAgZ2wgPT4gVEFSR0VUUy5tYXAoY29uc3RhbnQgPT4gZ2xbY29uc3RhbnRdKS5maWx0ZXIoY29uc3RhbnQgPT4gY29uc3RhbnQpO1xuXG4vLyBVU0FHRSBUWVBFU1xuXG5leHBvcnQgY29uc3QgQlVGRkVSX1VTQUdFID0gW1xuICAnU1RBVElDX0RSQVcnLCAvLyBCdWZmZXIgdXNlZCBvZnRlbiBhbmQgbm90IGNoYW5nZSBvZnRlbi4gQ29udGVudHMgYXJlIHdyaXR0ZW4gdG8gdGhlIGJ1ZmZlciwgYnV0IG5vdCByZWFkLlxuICAnRFlOQU1JQ19EUkFXJywgLy8gQnVmZmVyIHVzZWQgb2Z0ZW4gYW5kIGNoYW5nZSBvZnRlbi4gQ29udGVudHMgYXJlIHdyaXR0ZW4gdG8gdGhlIGJ1ZmZlciwgYnV0IG5vdCByZWFkLlxuICAnU1RSRUFNX0RSQVcnLCAvLyBCdWZmZXIgbm90IHVzZWQgb2Z0ZW4uIENvbnRlbnRzIGFyZSB3cml0dGVuIHRvIHRoZSBidWZmZXIsIGJ1dCBub3QgcmVhZC5cbiAgLy8gRm9yIFdlYkdMIDIgY29udGV4dHNcbiAgJ1NUQVRJQ19SRUFEJywgLy8gQnVmZmVyIHVzZWQgb2Z0ZW4gYW5kIG5vdCBjaGFuZ2Ugb2Z0ZW4uIENvbnRlbnRzIGFyZSByZWFkIGZyb20gdGhlIGJ1ZmZlciwgYnV0IG5vdCB3cml0dGVuLlxuICAnRFlOQU1JQ19SRUFEJywgLy8gQnVmZmVyIHVzZWQgb2Z0ZW4gYW5kIGNoYW5nZSBvZnRlbi4gQ29udGVudHMgYXJlIHJlYWQgZnJvbSB0aGUgYnVmZmVyLCBidXQgbm90IHdyaXR0ZW4uXG4gICdTVFJFQU1fUkVBRCcsIC8vIENvbnRlbnRzIG9mIHRoZSBidWZmZXIgYXJlIGxpa2VseSB0byBub3QgYmUgdXNlZCBvZnRlbi4gQ29udGVudHMgYXJlIHJlYWQgZnJvbSB0aGUgYnVmZmVyLCBidXQgbm90IHdyaXR0ZW4uXG4gICdTVEFUSUNfQ09QWScsIC8vIEJ1ZmZlciB1c2VkIG9mdGVuIGFuZCBub3QgY2hhbmdlIG9mdGVuLiBDb250ZW50cyBhcmUgbmVpdGhlciB3cml0dGVuIG9yIHJlYWQgYnkgdGhlIHVzZXIuXG4gICdEWU5BTUlDX0NPUFknLCAvLyBCdWZmZXIgdXNlZCBvZnRlbiBhbmQgY2hhbmdlIG9mdGVuLiBDb250ZW50cyBhcmUgbmVpdGhlciB3cml0dGVuIG9yIHJlYWQgYnkgdGhlIHVzZXIuXG4gICdTVFJFQU1fQ09QWScgLy8gQnVmZmVyIHVzZWQgb2Z0ZW4gYW5kIG5vdCBjaGFuZ2Ugb2Z0ZW4uIENvbnRlbnRzIGFyZSBuZWl0aGVyIHdyaXR0ZW4gb3IgcmVhZCBieSB0aGUgdXNlci5cbl07XG5cbmV4cG9ydCBjb25zdCBHTF9CVUZGRVJfVVNBR0UgPVxuICBnbCA9PiBCVUZGRVJfVVNBR0UubWFwKGNvbnN0YW50ID0+IGdsW2NvbnN0YW50XSkuZmlsdGVyKGNvbnN0YW50ID0+IGNvbnN0YW50KTtcblxuZnVuY3Rpb24gZ2V0S2V5KGdsLCB2YWx1ZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBnbCkge1xuICAgIGlmIChnbFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG4iXX0=