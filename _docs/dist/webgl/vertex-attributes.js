'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMaxAttributes = getMaxAttributes;
exports.hasDivisor = hasDivisor;
exports.isEnabled = isEnabled;
exports.getBuffer = getBuffer;
exports.getGeneric = getGeneric;
exports.getSize = getSize;
exports.getType = getType;
exports.isNormalized = isNormalized;
exports.isInteger = isInteger;
exports.getStride = getStride;
exports.getOffset = getOffset;
exports.enable = enable;
exports.disable = disable;
exports.setDivisor = setDivisor;
exports.getDivisor = getDivisor;
exports.setBuffer = setBuffer;
exports.setGeneric = setGeneric;
exports.setGenericValues = setGenericValues;

var _webglTypes = require('./webgl-types');

var _webglChecks = require('./webgl-checks');

var _buffer = require('./buffer');

var _buffer2 = _interopRequireDefault(_buffer);

var _context = require('./context');

var _utils = require('../utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Methods for manipulating the vertex attributes array, which is where
 * vertex data is staged for shader execution.
 *
 * Vertex attributes are stored in "arrays" with indices from 0 and up.
 * During shader execution, these indices (or 'locations') are matched to
 * the indices assigned to shader attributes during WebGLProgram linking.
 *
 * Note: The global state contains an implicit vertex attribute array which
 * the methods in this class manipulate by default. It is also possible to
 * create and bind a VertexArrayObject to manage multiple arrays.
 *
 * Each vertex attribute has these properties:
 * - Can be enabled or disabled (Only enable attrs actually used by a program)
 * - Has an instance `divisor` (usually 1 or 0 to enable/disable instancing)
 * - Have a size (1-4 values per vertex)
 * - Has a value or values that is accessible in shaders
 *
 * Attribute values are either
 * - Generic: a constant value for all vertices/instances, or
 * - Bound to a WebGLBuffer with unique values for each vertex/instance
 *
 * When binding to a WebGLBuffer it is necessary to specify the layout of
 * data in the buffer:
 * - size (1-4 values per vertex)
 * - data type (e.g. gl.FLOAT)
 * - stride, offset, and integer normalization policy can also be specified
 *
 * Note: All methods in this class take a `location` index to specify which
 * vertex attribute in the array they are operating on.
 *
 * Note: Attribute 0 can sometimes be treated specially by the driver,
 * to be safe we avoid disabling it.
 *
 * Note: WebGL2
 * - Improves support for integer attributes, both generic and buffered.
 * - Setting instance "divisors" no longer require using a WebGL extension.
 *
 */

var ERR_WEBGL2 = 'WebGL2 required';

function glGetLumaInfo(gl) {
  if (!gl.luma) {
    gl.luma = { extensions: {} };
  }
  if (gl.luma.extensions['ANGLE_instanced_arrays'] === undefined) {
    gl.luma.extensions['ANGLE_instanced_arrays'] = gl.getExtension('ANGLE_instanced_arrays');
  }
  return gl.luma;
}

// ACCESSORS

/**
 * The max number of attributes in the vertex attribute array is an
 * implementation defined limit, but never smaller than 8
 * @param {WebGLRenderingContext} gl - webgl context
 * @returns {GLuint} - (max) number of attributes in the vertex attribute array
 */
function getMaxAttributes(gl) {
  (0, _webglChecks.assertWebGLRenderingContext)(gl);
  return gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  return maxAttributes;
}

/**
 * Is instance divisor availble (checks for WebGL2 or ANGLE extension)
 * @param {WebGLRenderingContext} gl - webgl context
 * @returns {Boolean} - is divisor available?
 */
function hasDivisor(gl) {
  (0, _webglChecks.assertWebGLRenderingContext)(gl);
  return Boolean(gl instanceof _webglTypes.WebGL2RenderingContext || gl.getExtension(gl, 'ANGLE_instanced_arrays'));
}

/**
 * Returns true if the vertex attribute is enabled at this index.
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {Boolean} - enabled status
 */
function isEnabled(gl, location) {
  return Boolean(get(gl, location, gl.VERTEX_ATTRIB_ARRAY_ENABLED));
}

/**
 * Returns the currently bound buffer
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {WebGLBuffer} Returns the currently bound buffer
 */
function getBuffer(gl, location) {
  return get(gl, location, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);
}

/**
 * Get values for generic vertex attributes
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {Float32Array} (with 4 elements) representing the current value
 * of the vertex attribute at the given index.
 */
function getGeneric(gl, location) {
  return get(gl, gl.CURRENT_VERTEX_ATTRIB);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
// @returns {GLint} the size of an element of the vertex array.
function getSize(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_SIZE);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
// @returns {GLenum} representing the array type.
function getType(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_TYPE);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
// @returns {GLboolean} true if fixed-point data types are normalized
// for the vertex attribute array at the given index.
function isNormalized(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);
}

/**
 * check if an integer data type in the vertex attribute at index
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - index of the vertex attribute.
 * @returns {GLboolean} - true if an integer data type is in the
 * vertex attribute array at the given index.
 */
function isInteger(gl, location) {
  (0, _assert2.default)(gl instanceof _webglTypes.WebGL2RenderingContext, ERR_WEBGL2);
  return get(location, gl.VERTEX_ATTRIB_ARRAY_INTEGER);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {GLint} number of bytes between successive elements in the array.
 * 0 means that the elements are sequential.
 */
function getStride(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_STRIDE);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {GLuint} the address of a specified vertex attribute.
 */
function getOffset(gl, location) {
  var pname = arguments.length <= 2 || arguments[2] === undefined ? gl.VERTEX_ATTRIB_ARRAY_POINTER : arguments[2];

  return gl.getVertexAttribOffset(location, pname);
}

/**
 * @private
 * Generic getter for information about a vertex attribute at a given position
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - index of the vertex attribute.
 * @param {GLenum} pname - specifies the information to query.
 * @returns {*} - requested vertex attribute information (specified by pname)
 */
function get(gl, location, pname) {
  (0, _webglChecks.assertWebGLRenderingContext)(gl);
  return gl.getVertexAttrib(location, pname);
}

// MODIFIERS

/**
 * Enable the attribute
 * Note: By default all attributes are disabled. Only attributes
 * used by a program's shaders should be enabled.
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
function enable(gl, location) {
  gl.enableVertexAttribArray(location);
}

/**
 * Disable the attribute
 * Note: Only attributes used by a program's shaders should be enabled.
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
function disable(gl, location) {
  // Don't disable location 0
  if (location > 0) {
    gl.disableVertexAttribArray(location);
  }
}

/**
 * Set the frequency divisor used for instanced rendering.
 * Note: Usually simply set to 1 or 0 to enable/disable instanced rendering
 * for a specific attribute.
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @param {GLuint} divisor - instances that pass between updates of attribute
 */
function setDivisor(gl, location, divisor) {
  if (gl instanceof _webglTypes.WebGL2RenderingContext) {
    gl.vertexAttribDivisor(location, divisor);
    return;
  }
  var ext = glGetLumaInfo(gl).extensions['ANGLE_instanced_arrays'];
  if (ext) {
    ext.vertexAttribDivisorANGLE(location, divisor);
    return;
  }
  // Accept divisor 0 even if instancing is not supported (0 = no instancing)
  if (divisor !== 0) {
    throw new Error('WebGL instanced rendering not supported');
  }
}

/**
 * Returns the frequency divisor used for instanced rendering.
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {GLuint} divisor
 */
function getDivisor(gl, location) {
  (0, _assert2.default)(location > 0);
  if (gl instanceof _webglTypes.WebGL2RenderingContext) {
    var divisor = get(location, gl.VERTEX_ATTRIB_ARRAY_DIVISOR);
    return divisor;
  }
  var ext = glGetLumaInfo(gl).extensions['ANGLE_instanced_arrays'];
  if (ext) {
    var _divisor = get(location, ext.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
    return _divisor;
  }
  // if instancing is not available, return 0 meaning divisor has not been set
  return 0;
}

/**
 * Set a location in vertex attributes array to a buffer, specifying
 * its data layout and integer to float conversion and normalization flags
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @param {WebGLBuffer|Buffer} buffer - WebGL buffer to set as value
 * @param {GLuint} target=gl.ARRAY_BUFFER - which target to bind to
 * @param {Object} layout= Optional data layout, defaults to buffer's layout
 * @param {GLuint} layout.size - number of values per element (1-4)
 * @param {GLuint} layout.type - type of values (e.g. gl.FLOAT)
 * @param {GLbool} layout.normalized=false - normalize integers to [-1,1], [0,1]
 * @param {GLuint} layout.integer=false - WebGL2 only, disable int-to-float conv
 * @param {GLuint} layout.stride=0 - supports strided arrays
 * @param {GLuint} layout.offset=0 - supports strided arrays
 */
function setBuffer() {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var gl = _ref.gl;
  var location = _ref.location;
  var buffer = _ref.buffer;
  var target = _ref.target;
  var layout = _ref.layout;

  (0, _webglChecks.assertWebGLRenderingContext)(gl);
  buffer = _buffer2.default.makeFrom(gl, buffer);

  // Copy main data characteristics from buffer
  target = (0, _context.glGet)(gl, target !== undefined ? target : buffer.target);
  layout = layout !== undefined ? layout : buffer.layout;
  (0, _assert2.default)(target, 'setBuffer needs target');
  (0, _assert2.default)(layout, 'setBuffer called on uninitialized buffer');

  // a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target
  buffer.bind({ target: gl.ARRAY_BUFFER });

  // Attach bound ARRAY_BUFFER with specified buffer format to location
  if (!layout.integer) {
    gl.vertexAttribPointer(location, layout.size, (0, _context.glGet)(gl, layout.type), layout.normalized, layout.stride, layout.offset);
  } else {
    // specifies *integer* data formats and locations of vertex attributes
    // For glVertexAttribIPointer, Values are always left as integer values.
    // Only accepts the integer types gl.BYTE, gl.UNSIGNED_BYTE,
    // gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT
    (0, _assert2.default)(gl instanceof _webglTypes.WebGL2RenderingContext, ERR_WEBGL2);
    gl.vertexAttribIPointer(location, layout.size, (0, _context.glGet)(gl, layout.type), layout.stride, layout.offset);
  }

  buffer.unbind({ target: gl.ARRAY_BUFFER });
}

/*
 * Specify values for generic vertex attributes
 * Generic vertex attributes are constant for all vertices
 * Up to 4 values depending on attribute size
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @param {GLuint} divisor - instances that pass between updates of attribute
 */
function setGeneric(_ref2) {
  var gl = _ref2.gl;
  var location = _ref2.location;
  var array = _ref2.array;

  _utils.log.warn(0, 'VertexAttributes.setGeneric is not well tested');
  // throw new Error('vertex attribute size must be between 1 and 4');

  if (array instanceof Float32Array) {
    gl.vertexAttrib4fv(location, array);
  } else if (array instanceof Int32Array) {
    (0, _assert2.default)(gl instanceof _webglTypes.WebGL2RenderingContext, 'WebGL2 required');
    gl.vertexAttribI4iv(location, array);
  } else if (array instanceof Uint32Array) {
    (0, _assert2.default)(gl instanceof _webglTypes.WebGL2RenderingContext, 'WebGL2 required');
    gl.vertexAttribI4uiv(location, array);
  }
}

/*
 * Specify values for generic vertex attributes
 * Generic vertex attributes are constant for all vertices
 * Up to 4 values depending on attribute size
 *
 * @param {GLuint} location - ordinal number of the attribute
 * @param {GLuint} divisor - instances that pass between updates of attribute
 */
/* eslint-disable max-params */
function setGenericValues(gl, location, v0, v1, v2, v3) {
  _utils.log.warn(0, 'VertexAttributes.setGenericValues is not well tested');
  switch (arguments.length - 1) {
    case 1:
      gl.vertexAttrib1f(location, v0);break;
    case 2:
      gl.vertexAttrib2f(location, v0, v1);break;
    case 3:
      gl.vertexAttrib3f(location, v0, v1, v2);break;
    case 4:
      gl.vertexAttrib4f(location, v0, v1, v2, v3);break;
    default:
      throw new Error('vertex attribute size must be between 1 and 4');
  }

  // assert(gl instanceof WebGL2RenderingContext, 'WebGL2 required');
  // Looks like these will check how many arguments were supplied?
  // gl.vertexAttribI4i(location, v0, v1, v2, v3);
  // gl.vertexAttribI4ui(location, v0, v1, v2, v3);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC92ZXJ0ZXgtYXR0cmlidXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztRQW9FZ0IsZ0IsR0FBQSxnQjtRQVdBLFUsR0FBQSxVO1FBY0EsUyxHQUFBLFM7UUFVQSxTLEdBQUEsUztRQVdBLFUsR0FBQSxVO1FBU0EsTyxHQUFBLE87UUFTQSxPLEdBQUEsTztRQVVBLFksR0FBQSxZO1FBV0EsUyxHQUFBLFM7UUFXQSxTLEdBQUEsUztRQVNBLFMsR0FBQSxTO1FBNkJBLE0sR0FBQSxNO1FBV0EsTyxHQUFBLE87UUFnQkEsVSxHQUFBLFU7UUFzQkEsVSxHQUFBLFU7UUErQkEsUyxHQUFBLFM7UUF3REEsVSxHQUFBLFU7UUF3QkEsZ0IsR0FBQSxnQjs7QUExV2hCOztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBLElBQU0sYUFBYSxpQkFBbkI7O0FBRUEsU0FBUyxhQUFULENBQXVCLEVBQXZCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQyxHQUFHLElBQVIsRUFBYztBQUNaLE9BQUcsSUFBSCxHQUFVLEVBQUMsWUFBWSxFQUFiLEVBQVY7QUFDRDtBQUNELE1BQUksR0FBRyxJQUFILENBQVEsVUFBUixDQUFtQix3QkFBbkIsTUFBaUQsU0FBckQsRUFBZ0U7QUFDOUQsT0FBRyxJQUFILENBQVEsVUFBUixDQUFtQix3QkFBbkIsSUFDRSxHQUFHLFlBQUgsQ0FBZ0Isd0JBQWhCLENBREY7QUFFRDtBQUNELFNBQU8sR0FBRyxJQUFWO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7OztBQU1PLFNBQVMsZ0JBQVQsQ0FBMEIsRUFBMUIsRUFBOEI7QUFDbkMsZ0RBQTRCLEVBQTVCO0FBQ0EsU0FBTyxHQUFHLFlBQUgsQ0FBZ0IsR0FBRyxrQkFBbkIsQ0FBUDtBQUNBLFNBQU8sYUFBUDtBQUNEOztBQUVEOzs7OztBQUtPLFNBQVMsVUFBVCxD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RUFBd0MsRUFBeEMsRUFBNEMsRUFBNUMsRUFBZ0QsRUFBaEQsRUFBb0QsRUFBcEQsRUFBd0Q7QUFDN0QsYUFBSSxJQUFKLENBQVMsQ0FBVCxFQUFZLHNEQUFaO0FBQ0EsVUFBUSxVQUFVLE1BQVYsR0FBbUIsQ0FBM0I7QUFDQSxTQUFLLENBQUw7QUFBUSxTQUFHLGNBQUgsQ0FBa0IsUUFBbEIsRUFBNEIsRUFBNUIsRUFBaUM7QUFDekMsU0FBSyxDQUFMO0FBQVEsU0FBRyxjQUFILENBQWtCLFFBQWxCLEVBQTRCLEVBQTVCLEVBQWdDLEVBQWhDLEVBQXFDO0FBQzdDLFNBQUssQ0FBTDtBQUFRLFNBQUcsY0FBSCxDQUFrQixRQUFsQixFQUE0QixFQUE1QixFQUFnQyxFQUFoQyxFQUFvQyxFQUFwQyxFQUF5QztBQUNqRCxTQUFLLENBQUw7QUFBUSxTQUFHLGNBQUgsQ0FBa0IsUUFBbEIsRUFBNEIsRUFBNUIsRUFBZ0MsRUFBaEMsRUFBb0MsRUFBcEMsRUFBd0MsRUFBeEMsRUFBNkM7QUFDckQ7QUFDRSxZQUFNLElBQUksS0FBSixDQUFVLCtDQUFWLENBQU47QUFORjs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNEIiwiZmlsZSI6InZlcnRleC1hdHRyaWJ1dGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBmcm9tICcuL3dlYmdsLXR5cGVzJztcbmltcG9ydCB7YXNzZXJ0V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNoZWNrcyc7XG5pbXBvcnQgQnVmZmVyIGZyb20gJy4vYnVmZmVyJztcbmltcG9ydCB7Z2xHZXQsIGdsQ2hlY2tFcnJvcn0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7bG9nfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8qKlxuICogTWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIHRoZSB2ZXJ0ZXggYXR0cmlidXRlcyBhcnJheSwgd2hpY2ggaXMgd2hlcmVcbiAqIHZlcnRleCBkYXRhIGlzIHN0YWdlZCBmb3Igc2hhZGVyIGV4ZWN1dGlvbi5cbiAqXG4gKiBWZXJ0ZXggYXR0cmlidXRlcyBhcmUgc3RvcmVkIGluIFwiYXJyYXlzXCIgd2l0aCBpbmRpY2VzIGZyb20gMCBhbmQgdXAuXG4gKiBEdXJpbmcgc2hhZGVyIGV4ZWN1dGlvbiwgdGhlc2UgaW5kaWNlcyAob3IgJ2xvY2F0aW9ucycpIGFyZSBtYXRjaGVkIHRvXG4gKiB0aGUgaW5kaWNlcyBhc3NpZ25lZCB0byBzaGFkZXIgYXR0cmlidXRlcyBkdXJpbmcgV2ViR0xQcm9ncmFtIGxpbmtpbmcuXG4gKlxuICogTm90ZTogVGhlIGdsb2JhbCBzdGF0ZSBjb250YWlucyBhbiBpbXBsaWNpdCB2ZXJ0ZXggYXR0cmlidXRlIGFycmF5IHdoaWNoXG4gKiB0aGUgbWV0aG9kcyBpbiB0aGlzIGNsYXNzIG1hbmlwdWxhdGUgYnkgZGVmYXVsdC4gSXQgaXMgYWxzbyBwb3NzaWJsZSB0b1xuICogY3JlYXRlIGFuZCBiaW5kIGEgVmVydGV4QXJyYXlPYmplY3QgdG8gbWFuYWdlIG11bHRpcGxlIGFycmF5cy5cbiAqXG4gKiBFYWNoIHZlcnRleCBhdHRyaWJ1dGUgaGFzIHRoZXNlIHByb3BlcnRpZXM6XG4gKiAtIENhbiBiZSBlbmFibGVkIG9yIGRpc2FibGVkIChPbmx5IGVuYWJsZSBhdHRycyBhY3R1YWxseSB1c2VkIGJ5IGEgcHJvZ3JhbSlcbiAqIC0gSGFzIGFuIGluc3RhbmNlIGBkaXZpc29yYCAodXN1YWxseSAxIG9yIDAgdG8gZW5hYmxlL2Rpc2FibGUgaW5zdGFuY2luZylcbiAqIC0gSGF2ZSBhIHNpemUgKDEtNCB2YWx1ZXMgcGVyIHZlcnRleClcbiAqIC0gSGFzIGEgdmFsdWUgb3IgdmFsdWVzIHRoYXQgaXMgYWNjZXNzaWJsZSBpbiBzaGFkZXJzXG4gKlxuICogQXR0cmlidXRlIHZhbHVlcyBhcmUgZWl0aGVyXG4gKiAtIEdlbmVyaWM6IGEgY29uc3RhbnQgdmFsdWUgZm9yIGFsbCB2ZXJ0aWNlcy9pbnN0YW5jZXMsIG9yXG4gKiAtIEJvdW5kIHRvIGEgV2ViR0xCdWZmZXIgd2l0aCB1bmlxdWUgdmFsdWVzIGZvciBlYWNoIHZlcnRleC9pbnN0YW5jZVxuICpcbiAqIFdoZW4gYmluZGluZyB0byBhIFdlYkdMQnVmZmVyIGl0IGlzIG5lY2Vzc2FyeSB0byBzcGVjaWZ5IHRoZSBsYXlvdXQgb2ZcbiAqIGRhdGEgaW4gdGhlIGJ1ZmZlcjpcbiAqIC0gc2l6ZSAoMS00IHZhbHVlcyBwZXIgdmVydGV4KVxuICogLSBkYXRhIHR5cGUgKGUuZy4gZ2wuRkxPQVQpXG4gKiAtIHN0cmlkZSwgb2Zmc2V0LCBhbmQgaW50ZWdlciBub3JtYWxpemF0aW9uIHBvbGljeSBjYW4gYWxzbyBiZSBzcGVjaWZpZWRcbiAqXG4gKiBOb3RlOiBBbGwgbWV0aG9kcyBpbiB0aGlzIGNsYXNzIHRha2UgYSBgbG9jYXRpb25gIGluZGV4IHRvIHNwZWNpZnkgd2hpY2hcbiAqIHZlcnRleCBhdHRyaWJ1dGUgaW4gdGhlIGFycmF5IHRoZXkgYXJlIG9wZXJhdGluZyBvbi5cbiAqXG4gKiBOb3RlOiBBdHRyaWJ1dGUgMCBjYW4gc29tZXRpbWVzIGJlIHRyZWF0ZWQgc3BlY2lhbGx5IGJ5IHRoZSBkcml2ZXIsXG4gKiB0byBiZSBzYWZlIHdlIGF2b2lkIGRpc2FibGluZyBpdC5cbiAqXG4gKiBOb3RlOiBXZWJHTDJcbiAqIC0gSW1wcm92ZXMgc3VwcG9ydCBmb3IgaW50ZWdlciBhdHRyaWJ1dGVzLCBib3RoIGdlbmVyaWMgYW5kIGJ1ZmZlcmVkLlxuICogLSBTZXR0aW5nIGluc3RhbmNlIFwiZGl2aXNvcnNcIiBubyBsb25nZXIgcmVxdWlyZSB1c2luZyBhIFdlYkdMIGV4dGVuc2lvbi5cbiAqXG4gKi9cblxuY29uc3QgRVJSX1dFQkdMMiA9ICdXZWJHTDIgcmVxdWlyZWQnO1xuXG5mdW5jdGlvbiBnbEdldEx1bWFJbmZvKGdsKSB7XG4gIGlmICghZ2wubHVtYSkge1xuICAgIGdsLmx1bWEgPSB7ZXh0ZW5zaW9uczoge319O1xuICB9XG4gIGlmIChnbC5sdW1hLmV4dGVuc2lvbnNbJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wubHVtYS5leHRlbnNpb25zWydBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJ10gPVxuICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG4gIH1cbiAgcmV0dXJuIGdsLmx1bWE7XG59XG5cbi8vIEFDQ0VTU09SU1xuXG4vKipcbiAqIFRoZSBtYXggbnVtYmVyIG9mIGF0dHJpYnV0ZXMgaW4gdGhlIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgaXMgYW5cbiAqIGltcGxlbWVudGF0aW9uIGRlZmluZWQgbGltaXQsIGJ1dCBuZXZlciBzbWFsbGVyIHRoYW4gOFxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHJldHVybnMge0dMdWludH0gLSAobWF4KSBudW1iZXIgb2YgYXR0cmlidXRlcyBpbiB0aGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4QXR0cmlidXRlcyhnbCkge1xuICBhc3NlcnRXZWJHTFJlbmRlcmluZ0NvbnRleHQoZ2wpO1xuICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG4gIHJldHVybiBtYXhBdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIElzIGluc3RhbmNlIGRpdmlzb3IgYXZhaWxibGUgKGNoZWNrcyBmb3IgV2ViR0wyIG9yIEFOR0xFIGV4dGVuc2lvbilcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIGlzIGRpdmlzb3IgYXZhaWxhYmxlP1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRGl2aXNvcihnbCkge1xuICBhc3NlcnRXZWJHTFJlbmRlcmluZ0NvbnRleHQoZ2wpO1xuICByZXR1cm4gQm9vbGVhbihcbiAgICBnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfHxcbiAgICBnbC5nZXRFeHRlbnNpb24oZ2wsICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJylcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZlcnRleCBhdHRyaWJ1dGUgaXMgZW5hYmxlZCBhdCB0aGlzIGluZGV4LlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0Jvb2xlYW59IC0gZW5hYmxlZCBzdGF0dXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW5hYmxlZChnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIEJvb2xlYW4oZ2V0KGdsLCBsb2NhdGlvbiwgZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGJvdW5kIGJ1ZmZlclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybnMge1dlYkdMQnVmZmVyfSBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYm91bmQgYnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWZmZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBnZXQoZ2wsIGxvY2F0aW9uLCBnbC5WRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HKTtcbn1cblxuLyoqXG4gKiBHZXQgdmFsdWVzIGZvciBnZW5lcmljIHZlcnRleCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSAod2l0aCA0IGVsZW1lbnRzKSByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgdmFsdWVcbiAqIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlbmVyaWMoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBnZXQoZ2wsIGdsLkNVUlJFTlRfVkVSVEVYX0FUVFJJQik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG4vLyBAcmV0dXJucyB7R0xpbnR9IHRoZSBzaXplIG9mIGFuIGVsZW1lbnQgb2YgdGhlIHZlcnRleCBhcnJheS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZ2V0KGxvY2F0aW9uLCBnbC5WRVJURVhfQVRUUklCX0FSUkFZX1NJWkUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuLy8gQHJldHVybnMge0dMZW51bX0gcmVwcmVzZW50aW5nIHRoZSBhcnJheSB0eXBlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBnZXQobG9jYXRpb24sIGdsLlZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG4vLyBAcmV0dXJucyB7R0xib29sZWFufSB0cnVlIGlmIGZpeGVkLXBvaW50IGRhdGEgdHlwZXMgYXJlIG5vcm1hbGl6ZWRcbi8vIGZvciB0aGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5leHBvcnQgZnVuY3Rpb24gaXNOb3JtYWxpemVkKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZ2V0KGxvY2F0aW9uLCBnbC5WRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQpO1xufVxuXG4vKipcbiAqIGNoZWNrIGlmIGFuIGludGVnZXIgZGF0YSB0eXBlIGluIHRoZSB2ZXJ0ZXggYXR0cmlidXRlIGF0IGluZGV4XG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBpbmRleCBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIHtHTGJvb2xlYW59IC0gdHJ1ZSBpZiBhbiBpbnRlZ2VyIGRhdGEgdHlwZSBpcyBpbiB0aGVcbiAqIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgYXQgdGhlIGdpdmVuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKGdsLCBsb2NhdGlvbikge1xuICBhc3NlcnQoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LCBFUlJfV0VCR0wyKTtcbiAgcmV0dXJuIGdldChsb2NhdGlvbiwgZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9JTlRFR0VSKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7R0xpbnR9IG51bWJlciBvZiBieXRlcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxuICogMCBtZWFucyB0aGF0IHRoZSBlbGVtZW50cyBhcmUgc2VxdWVudGlhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmlkZShnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGdldChsb2NhdGlvbiwgZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtHTHVpbnR9IHRoZSBhZGRyZXNzIG9mIGEgc3BlY2lmaWVkIHZlcnRleCBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXQoXG4gIGdsLCBsb2NhdGlvbiwgcG5hbWUgPSBnbC5WRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVJcbikge1xuICByZXR1cm4gZ2wuZ2V0VmVydGV4QXR0cmliT2Zmc2V0KGxvY2F0aW9uLCBwbmFtZSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEdlbmVyaWMgZ2V0dGVyIGZvciBpbmZvcm1hdGlvbiBhYm91dCBhIHZlcnRleCBhdHRyaWJ1dGUgYXQgYSBnaXZlbiBwb3NpdGlvblxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gaW5kZXggb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge0dMZW51bX0gcG5hbWUgLSBzcGVjaWZpZXMgdGhlIGluZm9ybWF0aW9uIHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IC0gcmVxdWVzdGVkIHZlcnRleCBhdHRyaWJ1dGUgaW5mb3JtYXRpb24gKHNwZWNpZmllZCBieSBwbmFtZSlcbiAqL1xuZnVuY3Rpb24gZ2V0KGdsLCBsb2NhdGlvbiwgcG5hbWUpIHtcbiAgYXNzZXJ0V2ViR0xSZW5kZXJpbmdDb250ZXh0KGdsKTtcbiAgcmV0dXJuIGdsLmdldFZlcnRleEF0dHJpYihsb2NhdGlvbiwgcG5hbWUpO1xufVxuXG4vLyBNT0RJRklFUlNcblxuLyoqXG4gKiBFbmFibGUgdGhlIGF0dHJpYnV0ZVxuICogTm90ZTogQnkgZGVmYXVsdCBhbGwgYXR0cmlidXRlcyBhcmUgZGlzYWJsZWQuIE9ubHkgYXR0cmlidXRlc1xuICogdXNlZCBieSBhIHByb2dyYW0ncyBzaGFkZXJzIHNob3VsZCBiZSBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZShnbCwgbG9jYXRpb24pIHtcbiAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xufVxuXG4vKipcbiAqIERpc2FibGUgdGhlIGF0dHJpYnV0ZVxuICogTm90ZTogT25seSBhdHRyaWJ1dGVzIHVzZWQgYnkgYSBwcm9ncmFtJ3Mgc2hhZGVycyBzaG91bGQgYmUgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlKGdsLCBsb2NhdGlvbikge1xuICAvLyBEb24ndCBkaXNhYmxlIGxvY2F0aW9uIDBcbiAgaWYgKGxvY2F0aW9uID4gMCkge1xuICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGZyZXF1ZW5jeSBkaXZpc29yIHVzZWQgZm9yIGluc3RhbmNlZCByZW5kZXJpbmcuXG4gKiBOb3RlOiBVc3VhbGx5IHNpbXBseSBzZXQgdG8gMSBvciAwIHRvIGVuYWJsZS9kaXNhYmxlIGluc3RhbmNlZCByZW5kZXJpbmdcbiAqIGZvciBhIHNwZWNpZmljIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcGFyYW0ge0dMdWludH0gZGl2aXNvciAtIGluc3RhbmNlcyB0aGF0IHBhc3MgYmV0d2VlbiB1cGRhdGVzIG9mIGF0dHJpYnV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RGl2aXNvcihnbCwgbG9jYXRpb24sIGRpdmlzb3IpIHtcbiAgaWYgKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIGRpdmlzb3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBleHQgPSBnbEdldEx1bWFJbmZvKGdsKS5leHRlbnNpb25zWydBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJ107XG4gIGlmIChleHQpIHtcbiAgICBleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGxvY2F0aW9uLCBkaXZpc29yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gQWNjZXB0IGRpdmlzb3IgMCBldmVuIGlmIGluc3RhbmNpbmcgaXMgbm90IHN1cHBvcnRlZCAoMCA9IG5vIGluc3RhbmNpbmcpXG4gIGlmIChkaXZpc29yICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBpbnN0YW5jZWQgcmVuZGVyaW5nIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZyZXF1ZW5jeSBkaXZpc29yIHVzZWQgZm9yIGluc3RhbmNlZCByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7R0x1aW50fSBkaXZpc29yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXZpc29yKGdsLCBsb2NhdGlvbikge1xuICBhc3NlcnQobG9jYXRpb24gPiAwKTtcbiAgaWYgKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGNvbnN0IGRpdmlzb3IgPSBnZXQobG9jYXRpb24sIGdsLlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUik7XG4gICAgcmV0dXJuIGRpdmlzb3I7XG4gIH1cbiAgY29uc3QgZXh0ID0gZ2xHZXRMdW1hSW5mbyhnbCkuZXh0ZW5zaW9uc1snQU5HTEVfaW5zdGFuY2VkX2FycmF5cyddO1xuICBpZiAoZXh0KSB7XG4gICAgY29uc3QgZGl2aXNvciA9IGdldChsb2NhdGlvbiwgZXh0LlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUl9BTkdMRSk7XG4gICAgcmV0dXJuIGRpdmlzb3I7XG4gIH1cbiAgLy8gaWYgaW5zdGFuY2luZyBpcyBub3QgYXZhaWxhYmxlLCByZXR1cm4gMCBtZWFuaW5nIGRpdmlzb3IgaGFzIG5vdCBiZWVuIHNldFxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBTZXQgYSBsb2NhdGlvbiBpbiB2ZXJ0ZXggYXR0cmlidXRlcyBhcnJheSB0byBhIGJ1ZmZlciwgc3BlY2lmeWluZ1xuICogaXRzIGRhdGEgbGF5b3V0IGFuZCBpbnRlZ2VyIHRvIGZsb2F0IGNvbnZlcnNpb24gYW5kIG5vcm1hbGl6YXRpb24gZmxhZ3NcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcGFyYW0ge1dlYkdMQnVmZmVyfEJ1ZmZlcn0gYnVmZmVyIC0gV2ViR0wgYnVmZmVyIHRvIHNldCBhcyB2YWx1ZVxuICogQHBhcmFtIHtHTHVpbnR9IHRhcmdldD1nbC5BUlJBWV9CVUZGRVIgLSB3aGljaCB0YXJnZXQgdG8gYmluZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IGxheW91dD0gT3B0aW9uYWwgZGF0YSBsYXlvdXQsIGRlZmF1bHRzIHRvIGJ1ZmZlcidzIGxheW91dFxuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC5zaXplIC0gbnVtYmVyIG9mIHZhbHVlcyBwZXIgZWxlbWVudCAoMS00KVxuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC50eXBlIC0gdHlwZSBvZiB2YWx1ZXMgKGUuZy4gZ2wuRkxPQVQpXG4gKiBAcGFyYW0ge0dMYm9vbH0gbGF5b3V0Lm5vcm1hbGl6ZWQ9ZmFsc2UgLSBub3JtYWxpemUgaW50ZWdlcnMgdG8gWy0xLDFdLCBbMCwxXVxuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC5pbnRlZ2VyPWZhbHNlIC0gV2ViR0wyIG9ubHksIGRpc2FibGUgaW50LXRvLWZsb2F0IGNvbnZcbiAqIEBwYXJhbSB7R0x1aW50fSBsYXlvdXQuc3RyaWRlPTAgLSBzdXBwb3J0cyBzdHJpZGVkIGFycmF5c1xuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC5vZmZzZXQ9MCAtIHN1cHBvcnRzIHN0cmlkZWQgYXJyYXlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRCdWZmZXIoe1xuICBnbCxcbiAgbG9jYXRpb24sXG4gIGJ1ZmZlcixcbiAgdGFyZ2V0LFxuICBsYXlvdXRcbn0gPSB7fSkge1xuICBhc3NlcnRXZWJHTFJlbmRlcmluZ0NvbnRleHQoZ2wpO1xuICBidWZmZXIgPSBCdWZmZXIubWFrZUZyb20oZ2wsIGJ1ZmZlcik7XG5cbiAgLy8gQ29weSBtYWluIGRhdGEgY2hhcmFjdGVyaXN0aWNzIGZyb20gYnVmZmVyXG4gIHRhcmdldCA9IGdsR2V0KGdsLCB0YXJnZXQgIT09IHVuZGVmaW5lZCA/IHRhcmdldCA6IGJ1ZmZlci50YXJnZXQpO1xuICBsYXlvdXQgPSBsYXlvdXQgIT09IHVuZGVmaW5lZCA/IGxheW91dCA6IGJ1ZmZlci5sYXlvdXQ7XG4gIGFzc2VydCh0YXJnZXQsICdzZXRCdWZmZXIgbmVlZHMgdGFyZ2V0Jyk7XG4gIGFzc2VydChsYXlvdXQsICdzZXRCdWZmZXIgY2FsbGVkIG9uIHVuaW5pdGlhbGl6ZWQgYnVmZmVyJyk7XG5cbiAgLy8gYSBub24temVybyBuYW1lZCBidWZmZXIgb2JqZWN0IG11c3QgYmUgYm91bmQgdG8gdGhlIEdMX0FSUkFZX0JVRkZFUiB0YXJnZXRcbiAgYnVmZmVyLmJpbmQoe3RhcmdldDogZ2wuQVJSQVlfQlVGRkVSfSk7XG5cbiAgLy8gQXR0YWNoIGJvdW5kIEFSUkFZX0JVRkZFUiB3aXRoIHNwZWNpZmllZCBidWZmZXIgZm9ybWF0IHRvIGxvY2F0aW9uXG4gIGlmICghbGF5b3V0LmludGVnZXIpIHtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBsYXlvdXQuc2l6ZSxcbiAgICAgIGdsR2V0KGdsLCBsYXlvdXQudHlwZSksXG4gICAgICBsYXlvdXQubm9ybWFsaXplZCxcbiAgICAgIGxheW91dC5zdHJpZGUsXG4gICAgICBsYXlvdXQub2Zmc2V0XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzcGVjaWZpZXMgKmludGVnZXIqIGRhdGEgZm9ybWF0cyBhbmQgbG9jYXRpb25zIG9mIHZlcnRleCBhdHRyaWJ1dGVzXG4gICAgLy8gRm9yIGdsVmVydGV4QXR0cmliSVBvaW50ZXIsIFZhbHVlcyBhcmUgYWx3YXlzIGxlZnQgYXMgaW50ZWdlciB2YWx1ZXMuXG4gICAgLy8gT25seSBhY2NlcHRzIHRoZSBpbnRlZ2VyIHR5cGVzIGdsLkJZVEUsIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgLy8gZ2wuU0hPUlQsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5JTlQsIGdsLlVOU0lHTkVEX0lOVFxuICAgIGFzc2VydChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIEVSUl9XRUJHTDIpO1xuICAgIGdsLnZlcnRleEF0dHJpYklQb2ludGVyKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBsYXlvdXQuc2l6ZSxcbiAgICAgIGdsR2V0KGdsLCBsYXlvdXQudHlwZSksXG4gICAgICBsYXlvdXQuc3RyaWRlLFxuICAgICAgbGF5b3V0Lm9mZnNldFxuICAgICk7XG4gIH1cblxuICBidWZmZXIudW5iaW5kKHt0YXJnZXQ6IGdsLkFSUkFZX0JVRkZFUn0pO1xufVxuXG4vKlxuICogU3BlY2lmeSB2YWx1ZXMgZm9yIGdlbmVyaWMgdmVydGV4IGF0dHJpYnV0ZXNcbiAqIEdlbmVyaWMgdmVydGV4IGF0dHJpYnV0ZXMgYXJlIGNvbnN0YW50IGZvciBhbGwgdmVydGljZXNcbiAqIFVwIHRvIDQgdmFsdWVzIGRlcGVuZGluZyBvbiBhdHRyaWJ1dGUgc2l6ZVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7R0x1aW50fSBkaXZpc29yIC0gaW5zdGFuY2VzIHRoYXQgcGFzcyBiZXR3ZWVuIHVwZGF0ZXMgb2YgYXR0cmlidXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRHZW5lcmljKHtnbCwgbG9jYXRpb24sIGFycmF5fSkge1xuICBsb2cud2FybigwLCAnVmVydGV4QXR0cmlidXRlcy5zZXRHZW5lcmljIGlzIG5vdCB3ZWxsIHRlc3RlZCcpO1xuICAvLyB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRleCBhdHRyaWJ1dGUgc2l6ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNCcpO1xuXG4gIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgIGdsLnZlcnRleEF0dHJpYjRmdihsb2NhdGlvbiwgYXJyYXkpO1xuICB9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgIGFzc2VydChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsICdXZWJHTDIgcmVxdWlyZWQnKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJJNGl2KGxvY2F0aW9uLCBhcnJheSk7XG4gIH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuICAgIGFzc2VydChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsICdXZWJHTDIgcmVxdWlyZWQnKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJJNHVpdihsb2NhdGlvbiwgYXJyYXkpO1xuICB9XG59XG5cbi8qXG4gKiBTcGVjaWZ5IHZhbHVlcyBmb3IgZ2VuZXJpYyB2ZXJ0ZXggYXR0cmlidXRlc1xuICogR2VuZXJpYyB2ZXJ0ZXggYXR0cmlidXRlcyBhcmUgY29uc3RhbnQgZm9yIGFsbCB2ZXJ0aWNlc1xuICogVXAgdG8gNCB2YWx1ZXMgZGVwZW5kaW5nIG9uIGF0dHJpYnV0ZSBzaXplXG4gKlxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtHTHVpbnR9IGRpdmlzb3IgLSBpbnN0YW5jZXMgdGhhdCBwYXNzIGJldHdlZW4gdXBkYXRlcyBvZiBhdHRyaWJ1dGVcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LXBhcmFtcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEdlbmVyaWNWYWx1ZXMoZ2wsIGxvY2F0aW9uLCB2MCwgdjEsIHYyLCB2Mykge1xuICBsb2cud2FybigwLCAnVmVydGV4QXR0cmlidXRlcy5zZXRHZW5lcmljVmFsdWVzIGlzIG5vdCB3ZWxsIHRlc3RlZCcpO1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGggLSAxKSB7XG4gIGNhc2UgMTogZ2wudmVydGV4QXR0cmliMWYobG9jYXRpb24sIHYwKTsgYnJlYWs7XG4gIGNhc2UgMjogZ2wudmVydGV4QXR0cmliMmYobG9jYXRpb24sIHYwLCB2MSk7IGJyZWFrO1xuICBjYXNlIDM6IGdsLnZlcnRleEF0dHJpYjNmKGxvY2F0aW9uLCB2MCwgdjEsIHYyKTsgYnJlYWs7XG4gIGNhc2UgNDogZ2wudmVydGV4QXR0cmliNGYobG9jYXRpb24sIHYwLCB2MSwgdjIsIHYzKTsgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggYXR0cmlidXRlIHNpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDQnKTtcbiAgfVxuXG4gIC8vIGFzc2VydChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsICdXZWJHTDIgcmVxdWlyZWQnKTtcbiAgLy8gTG9va3MgbGlrZSB0aGVzZSB3aWxsIGNoZWNrIGhvdyBtYW55IGFyZ3VtZW50cyB3ZXJlIHN1cHBsaWVkP1xuICAvLyBnbC52ZXJ0ZXhBdHRyaWJJNGkobG9jYXRpb24sIHYwLCB2MSwgdjIsIHYzKTtcbiAgLy8gZ2wudmVydGV4QXR0cmliSTR1aShsb2NhdGlvbiwgdjAsIHYxLCB2MiwgdjMpO1xufVxuIl19